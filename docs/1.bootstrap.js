(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[1],{

/***/ "../Portable-Reasoning-in-Web-Assembly/sophia-wasm/pkg sync recursive":
/*!******************************************************************!*\
  !*** ../Portable-Reasoning-in-Web-Assembly/sophia-wasm/pkg sync ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = \"../Portable-Reasoning-in-Web-Assembly/sophia-wasm/pkg sync recursive\";\n\n//# sourceURL=webpack:///../Portable-Reasoning-in-Web-Assembly/sophia-wasm/pkg_sync?");

/***/ }),

/***/ "../Portable-Reasoning-in-Web-Assembly/sophia-wasm/pkg/sophia_wasm.js":
/*!****************************************************************************!*\
  !*** ../Portable-Reasoning-in-Web-Assembly/sophia-wasm/pkg/sophia_wasm.js ***!
  \****************************************************************************/
/*! exports provided: sumvectorfullrust, ArrayDataset, DataFactory, Datasetcore, FastDataset, FastDatasetToA, FullDataset, FullDatasetToA, IntTree, IntVector, LightDataset, LightDatasetToA, Quad, RandomValues, RustExportIterator, RustExportIteratorNext, Term, TreeDataset, TreeDatasetToA, __wbindgen_object_drop_ref, __wbg_termtype_a4a786613f0caa0c, __wbg_value_e1025b733d3dba1e, __wbg_language_879613ccdf6a457b, __wbg_datatype_2ba7293e0b888706, __wbg_log_83c9c7e7afe8209f, __wbindgen_is_null, __wbindgen_is_undefined, __wbg_term_new, __wbg_subject_048e66f68a4b1268, __wbg_object_54cb599f4cc13178, __wbg_predicate_348a7e9650639bdd, __wbg_graph_4185eaeb9b616609, __wbg_quadsgetrustptr_e356b53a099c2f60, __wbg_quad_new, __wbindgen_object_clone_ref, __wbg_getsophiadatasetptr_75cef6ca00ba6515, __wbindgen_is_falsy, __wbg_getsophiadatasetptr_a4d4b90cb7b6cef6, __wbg_getsophiadatasetptr_d6660d2c5b1b0122, __wbg_getsophiadatasetptr_8af02521c77b8172, __wbg_getsophiadatasetptr_fd13de8002947660, __wbg_getsophiadatasetptr_cd4122b7c7bee63a, __wbg_getsophiadatasetptr_4d9e9165c5b31627, __wbg_getsophiadatasetptr_85e6682f053e1121, __wbg_getsophiadatasetptr_16ee8ea079b18b62, __wbg_getsophiadatasetptr_bdb7942fc9f67c06, __wbg_self_1b7a39e3a92c949c, __wbg_require_604837428532a733, __wbg_crypto_968f1772287e2df0, __wbg_getRandomValues_a3d34b4fee3c2869, __wbg_getRandomValues_f5e14ab7ac8e995d, __wbg_randomFillSync_d5bd2d655fdf256a, __wbg_get_5fd9dd78e47d6ed2, __wbg_length_0f0e68fde7e14c19, __wbindgen_is_function, __wbindgen_is_object, __wbg_next_3d6c9b2822b18fae, __wbg_next_d2c829783697bd8e, __wbg_done_a16709ea72553788, __wbg_value_3093fb48085878da, __wbg_iterator_f89e8caf932523b1, __wbg_get_f2faf882de3801f1, __wbg_call_1f85aaa5836dfb23, __wbg_new_0d50725e1ae68303, __wbg_pop_b02b7e73b5ac41c0, __wbg_push_46274b393147c746, __wbg_reverse_20f3cefd76d7f0da, __wbg_call_0246f1c8ff252fb6, __wbg_call_740b86f47a550a76, __wbindgen_string_get, __wbindgen_debug_string, __wbindgen_throw */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sophia_wasm_bg.wasm */ \"../Portable-Reasoning-in-Web-Assembly/sophia-wasm/pkg/sophia_wasm_bg.wasm\");\n/* harmony import */ var _sophia_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sophia_wasm_bg.js */ \"../Portable-Reasoning-in-Web-Assembly/sophia-wasm/pkg/sophia_wasm_bg.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"sumvectorfullrust\", function() { return _sophia_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"sumvectorfullrust\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ArrayDataset\", function() { return _sophia_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"ArrayDataset\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"DataFactory\", function() { return _sophia_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"DataFactory\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Datasetcore\", function() { return _sophia_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"Datasetcore\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"FastDataset\", function() { return _sophia_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"FastDataset\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"FastDatasetToA\", function() { return _sophia_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"FastDatasetToA\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"FullDataset\", function() { return _sophia_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"FullDataset\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"FullDatasetToA\", function() { return _sophia_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"FullDatasetToA\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"IntTree\", function() { return _sophia_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"IntTree\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"IntVector\", function() { return _sophia_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"IntVector\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"LightDataset\", function() { return _sophia_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"LightDataset\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"LightDatasetToA\", function() { return _sophia_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"LightDatasetToA\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Quad\", function() { return _sophia_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"Quad\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"RandomValues\", function() { return _sophia_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"RandomValues\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"RustExportIterator\", function() { return _sophia_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"RustExportIterator\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"RustExportIteratorNext\", function() { return _sophia_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"RustExportIteratorNext\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Term\", function() { return _sophia_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"Term\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"TreeDataset\", function() { return _sophia_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"TreeDataset\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"TreeDatasetToA\", function() { return _sophia_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"TreeDatasetToA\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbindgen_object_drop_ref\", function() { return _sophia_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbindgen_object_drop_ref\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbg_termtype_a4a786613f0caa0c\", function() { return _sophia_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbg_termtype_a4a786613f0caa0c\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbg_value_e1025b733d3dba1e\", function() { return _sophia_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbg_value_e1025b733d3dba1e\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbg_language_879613ccdf6a457b\", function() { return _sophia_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbg_language_879613ccdf6a457b\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbg_datatype_2ba7293e0b888706\", function() { return _sophia_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbg_datatype_2ba7293e0b888706\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbg_log_83c9c7e7afe8209f\", function() { return _sophia_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbg_log_83c9c7e7afe8209f\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbindgen_is_null\", function() { return _sophia_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbindgen_is_null\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbindgen_is_undefined\", function() { return _sophia_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbindgen_is_undefined\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbg_term_new\", function() { return _sophia_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbg_term_new\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbg_subject_048e66f68a4b1268\", function() { return _sophia_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbg_subject_048e66f68a4b1268\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbg_object_54cb599f4cc13178\", function() { return _sophia_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbg_object_54cb599f4cc13178\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbg_predicate_348a7e9650639bdd\", function() { return _sophia_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbg_predicate_348a7e9650639bdd\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbg_graph_4185eaeb9b616609\", function() { return _sophia_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbg_graph_4185eaeb9b616609\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbg_quadsgetrustptr_e356b53a099c2f60\", function() { return _sophia_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbg_quadsgetrustptr_e356b53a099c2f60\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbg_quad_new\", function() { return _sophia_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbg_quad_new\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbindgen_object_clone_ref\", function() { return _sophia_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbindgen_object_clone_ref\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbg_getsophiadatasetptr_75cef6ca00ba6515\", function() { return _sophia_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbg_getsophiadatasetptr_75cef6ca00ba6515\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbindgen_is_falsy\", function() { return _sophia_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbindgen_is_falsy\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbg_getsophiadatasetptr_a4d4b90cb7b6cef6\", function() { return _sophia_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbg_getsophiadatasetptr_a4d4b90cb7b6cef6\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbg_getsophiadatasetptr_d6660d2c5b1b0122\", function() { return _sophia_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbg_getsophiadatasetptr_d6660d2c5b1b0122\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbg_getsophiadatasetptr_8af02521c77b8172\", function() { return _sophia_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbg_getsophiadatasetptr_8af02521c77b8172\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbg_getsophiadatasetptr_fd13de8002947660\", function() { return _sophia_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbg_getsophiadatasetptr_fd13de8002947660\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbg_getsophiadatasetptr_cd4122b7c7bee63a\", function() { return _sophia_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbg_getsophiadatasetptr_cd4122b7c7bee63a\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbg_getsophiadatasetptr_4d9e9165c5b31627\", function() { return _sophia_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbg_getsophiadatasetptr_4d9e9165c5b31627\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbg_getsophiadatasetptr_85e6682f053e1121\", function() { return _sophia_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbg_getsophiadatasetptr_85e6682f053e1121\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbg_getsophiadatasetptr_16ee8ea079b18b62\", function() { return _sophia_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbg_getsophiadatasetptr_16ee8ea079b18b62\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbg_getsophiadatasetptr_bdb7942fc9f67c06\", function() { return _sophia_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbg_getsophiadatasetptr_bdb7942fc9f67c06\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbg_self_1b7a39e3a92c949c\", function() { return _sophia_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbg_self_1b7a39e3a92c949c\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbg_require_604837428532a733\", function() { return _sophia_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbg_require_604837428532a733\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbg_crypto_968f1772287e2df0\", function() { return _sophia_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbg_crypto_968f1772287e2df0\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbg_getRandomValues_a3d34b4fee3c2869\", function() { return _sophia_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbg_getRandomValues_a3d34b4fee3c2869\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbg_getRandomValues_f5e14ab7ac8e995d\", function() { return _sophia_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbg_getRandomValues_f5e14ab7ac8e995d\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbg_randomFillSync_d5bd2d655fdf256a\", function() { return _sophia_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbg_randomFillSync_d5bd2d655fdf256a\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbg_get_5fd9dd78e47d6ed2\", function() { return _sophia_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbg_get_5fd9dd78e47d6ed2\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbg_length_0f0e68fde7e14c19\", function() { return _sophia_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbg_length_0f0e68fde7e14c19\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbindgen_is_function\", function() { return _sophia_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbindgen_is_function\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbindgen_is_object\", function() { return _sophia_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbindgen_is_object\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbg_next_3d6c9b2822b18fae\", function() { return _sophia_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbg_next_3d6c9b2822b18fae\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbg_next_d2c829783697bd8e\", function() { return _sophia_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbg_next_d2c829783697bd8e\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbg_done_a16709ea72553788\", function() { return _sophia_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbg_done_a16709ea72553788\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbg_value_3093fb48085878da\", function() { return _sophia_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbg_value_3093fb48085878da\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbg_iterator_f89e8caf932523b1\", function() { return _sophia_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbg_iterator_f89e8caf932523b1\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbg_get_f2faf882de3801f1\", function() { return _sophia_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbg_get_f2faf882de3801f1\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbg_call_1f85aaa5836dfb23\", function() { return _sophia_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbg_call_1f85aaa5836dfb23\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbg_new_0d50725e1ae68303\", function() { return _sophia_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbg_new_0d50725e1ae68303\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbg_pop_b02b7e73b5ac41c0\", function() { return _sophia_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbg_pop_b02b7e73b5ac41c0\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbg_push_46274b393147c746\", function() { return _sophia_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbg_push_46274b393147c746\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbg_reverse_20f3cefd76d7f0da\", function() { return _sophia_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbg_reverse_20f3cefd76d7f0da\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbg_call_0246f1c8ff252fb6\", function() { return _sophia_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbg_call_0246f1c8ff252fb6\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbg_call_740b86f47a550a76\", function() { return _sophia_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbg_call_740b86f47a550a76\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbindgen_string_get\", function() { return _sophia_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbindgen_string_get\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbindgen_debug_string\", function() { return _sophia_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbindgen_debug_string\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbindgen_throw\", function() { return _sophia_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbindgen_throw\"]; });\n\n\n\n\n//# sourceURL=webpack:///../Portable-Reasoning-in-Web-Assembly/sophia-wasm/pkg/sophia_wasm.js?");

/***/ }),

/***/ "../Portable-Reasoning-in-Web-Assembly/sophia-wasm/pkg/sophia_wasm_bg.js":
/*!*******************************************************************************!*\
  !*** ../Portable-Reasoning-in-Web-Assembly/sophia-wasm/pkg/sophia_wasm_bg.js ***!
  \*******************************************************************************/
/*! exports provided: sumvectorfullrust, ArrayDataset, DataFactory, Datasetcore, FastDataset, FastDatasetToA, FullDataset, FullDatasetToA, IntTree, IntVector, LightDataset, LightDatasetToA, Quad, RandomValues, RustExportIterator, RustExportIteratorNext, Term, TreeDataset, TreeDatasetToA, __wbindgen_object_drop_ref, __wbg_termtype_a4a786613f0caa0c, __wbg_value_e1025b733d3dba1e, __wbg_language_879613ccdf6a457b, __wbg_datatype_2ba7293e0b888706, __wbg_log_83c9c7e7afe8209f, __wbindgen_is_null, __wbindgen_is_undefined, __wbg_term_new, __wbg_subject_048e66f68a4b1268, __wbg_object_54cb599f4cc13178, __wbg_predicate_348a7e9650639bdd, __wbg_graph_4185eaeb9b616609, __wbg_quadsgetrustptr_e356b53a099c2f60, __wbg_quad_new, __wbindgen_object_clone_ref, __wbg_getsophiadatasetptr_75cef6ca00ba6515, __wbindgen_is_falsy, __wbg_getsophiadatasetptr_a4d4b90cb7b6cef6, __wbg_getsophiadatasetptr_d6660d2c5b1b0122, __wbg_getsophiadatasetptr_8af02521c77b8172, __wbg_getsophiadatasetptr_fd13de8002947660, __wbg_getsophiadatasetptr_cd4122b7c7bee63a, __wbg_getsophiadatasetptr_4d9e9165c5b31627, __wbg_getsophiadatasetptr_85e6682f053e1121, __wbg_getsophiadatasetptr_16ee8ea079b18b62, __wbg_getsophiadatasetptr_bdb7942fc9f67c06, __wbg_self_1b7a39e3a92c949c, __wbg_require_604837428532a733, __wbg_crypto_968f1772287e2df0, __wbg_getRandomValues_a3d34b4fee3c2869, __wbg_getRandomValues_f5e14ab7ac8e995d, __wbg_randomFillSync_d5bd2d655fdf256a, __wbg_get_5fd9dd78e47d6ed2, __wbg_length_0f0e68fde7e14c19, __wbindgen_is_function, __wbindgen_is_object, __wbg_next_3d6c9b2822b18fae, __wbg_next_d2c829783697bd8e, __wbg_done_a16709ea72553788, __wbg_value_3093fb48085878da, __wbg_iterator_f89e8caf932523b1, __wbg_get_f2faf882de3801f1, __wbg_call_1f85aaa5836dfb23, __wbg_new_0d50725e1ae68303, __wbg_pop_b02b7e73b5ac41c0, __wbg_push_46274b393147c746, __wbg_reverse_20f3cefd76d7f0da, __wbg_call_0246f1c8ff252fb6, __wbg_call_740b86f47a550a76, __wbindgen_string_get, __wbindgen_debug_string, __wbindgen_throw */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sumvectorfullrust\", function() { return sumvectorfullrust; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ArrayDataset\", function() { return ArrayDataset; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DataFactory\", function() { return DataFactory; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Datasetcore\", function() { return Datasetcore; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FastDataset\", function() { return FastDataset; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FastDatasetToA\", function() { return FastDatasetToA; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FullDataset\", function() { return FullDataset; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FullDatasetToA\", function() { return FullDatasetToA; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"IntTree\", function() { return IntTree; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"IntVector\", function() { return IntVector; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LightDataset\", function() { return LightDataset; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LightDatasetToA\", function() { return LightDatasetToA; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Quad\", function() { return Quad; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RandomValues\", function() { return RandomValues; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RustExportIterator\", function() { return RustExportIterator; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RustExportIteratorNext\", function() { return RustExportIteratorNext; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Term\", function() { return Term; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TreeDataset\", function() { return TreeDataset; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TreeDatasetToA\", function() { return TreeDatasetToA; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbindgen_object_drop_ref\", function() { return __wbindgen_object_drop_ref; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbg_termtype_a4a786613f0caa0c\", function() { return __wbg_termtype_a4a786613f0caa0c; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbg_value_e1025b733d3dba1e\", function() { return __wbg_value_e1025b733d3dba1e; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbg_language_879613ccdf6a457b\", function() { return __wbg_language_879613ccdf6a457b; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbg_datatype_2ba7293e0b888706\", function() { return __wbg_datatype_2ba7293e0b888706; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbg_log_83c9c7e7afe8209f\", function() { return __wbg_log_83c9c7e7afe8209f; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbindgen_is_null\", function() { return __wbindgen_is_null; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbindgen_is_undefined\", function() { return __wbindgen_is_undefined; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbg_term_new\", function() { return __wbg_term_new; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbg_subject_048e66f68a4b1268\", function() { return __wbg_subject_048e66f68a4b1268; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbg_object_54cb599f4cc13178\", function() { return __wbg_object_54cb599f4cc13178; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbg_predicate_348a7e9650639bdd\", function() { return __wbg_predicate_348a7e9650639bdd; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbg_graph_4185eaeb9b616609\", function() { return __wbg_graph_4185eaeb9b616609; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbg_quadsgetrustptr_e356b53a099c2f60\", function() { return __wbg_quadsgetrustptr_e356b53a099c2f60; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbg_quad_new\", function() { return __wbg_quad_new; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbindgen_object_clone_ref\", function() { return __wbindgen_object_clone_ref; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbg_getsophiadatasetptr_75cef6ca00ba6515\", function() { return __wbg_getsophiadatasetptr_75cef6ca00ba6515; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbindgen_is_falsy\", function() { return __wbindgen_is_falsy; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbg_getsophiadatasetptr_a4d4b90cb7b6cef6\", function() { return __wbg_getsophiadatasetptr_a4d4b90cb7b6cef6; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbg_getsophiadatasetptr_d6660d2c5b1b0122\", function() { return __wbg_getsophiadatasetptr_d6660d2c5b1b0122; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbg_getsophiadatasetptr_8af02521c77b8172\", function() { return __wbg_getsophiadatasetptr_8af02521c77b8172; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbg_getsophiadatasetptr_fd13de8002947660\", function() { return __wbg_getsophiadatasetptr_fd13de8002947660; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbg_getsophiadatasetptr_cd4122b7c7bee63a\", function() { return __wbg_getsophiadatasetptr_cd4122b7c7bee63a; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbg_getsophiadatasetptr_4d9e9165c5b31627\", function() { return __wbg_getsophiadatasetptr_4d9e9165c5b31627; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbg_getsophiadatasetptr_85e6682f053e1121\", function() { return __wbg_getsophiadatasetptr_85e6682f053e1121; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbg_getsophiadatasetptr_16ee8ea079b18b62\", function() { return __wbg_getsophiadatasetptr_16ee8ea079b18b62; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbg_getsophiadatasetptr_bdb7942fc9f67c06\", function() { return __wbg_getsophiadatasetptr_bdb7942fc9f67c06; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbg_self_1b7a39e3a92c949c\", function() { return __wbg_self_1b7a39e3a92c949c; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbg_require_604837428532a733\", function() { return __wbg_require_604837428532a733; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbg_crypto_968f1772287e2df0\", function() { return __wbg_crypto_968f1772287e2df0; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbg_getRandomValues_a3d34b4fee3c2869\", function() { return __wbg_getRandomValues_a3d34b4fee3c2869; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbg_getRandomValues_f5e14ab7ac8e995d\", function() { return __wbg_getRandomValues_f5e14ab7ac8e995d; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbg_randomFillSync_d5bd2d655fdf256a\", function() { return __wbg_randomFillSync_d5bd2d655fdf256a; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbg_get_5fd9dd78e47d6ed2\", function() { return __wbg_get_5fd9dd78e47d6ed2; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbg_length_0f0e68fde7e14c19\", function() { return __wbg_length_0f0e68fde7e14c19; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbindgen_is_function\", function() { return __wbindgen_is_function; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbindgen_is_object\", function() { return __wbindgen_is_object; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbg_next_3d6c9b2822b18fae\", function() { return __wbg_next_3d6c9b2822b18fae; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbg_next_d2c829783697bd8e\", function() { return __wbg_next_d2c829783697bd8e; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbg_done_a16709ea72553788\", function() { return __wbg_done_a16709ea72553788; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbg_value_3093fb48085878da\", function() { return __wbg_value_3093fb48085878da; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbg_iterator_f89e8caf932523b1\", function() { return __wbg_iterator_f89e8caf932523b1; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbg_get_f2faf882de3801f1\", function() { return __wbg_get_f2faf882de3801f1; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbg_call_1f85aaa5836dfb23\", function() { return __wbg_call_1f85aaa5836dfb23; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbg_new_0d50725e1ae68303\", function() { return __wbg_new_0d50725e1ae68303; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbg_pop_b02b7e73b5ac41c0\", function() { return __wbg_pop_b02b7e73b5ac41c0; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbg_push_46274b393147c746\", function() { return __wbg_push_46274b393147c746; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbg_reverse_20f3cefd76d7f0da\", function() { return __wbg_reverse_20f3cefd76d7f0da; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbg_call_0246f1c8ff252fb6\", function() { return __wbg_call_0246f1c8ff252fb6; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbg_call_740b86f47a550a76\", function() { return __wbg_call_740b86f47a550a76; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbindgen_string_get\", function() { return __wbindgen_string_get; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbindgen_debug_string\", function() { return __wbindgen_debug_string; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbindgen_throw\", function() { return __wbindgen_throw; });\n/* harmony import */ var _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sophia_wasm_bg.wasm */ \"../Portable-Reasoning-in-Web-Assembly/sophia-wasm/pkg/sophia_wasm_bg.wasm\");\n\n\nconst heap = new Array(32).fill(undefined);\n\nheap.push(undefined, null, true, false);\n\nfunction getObject(idx) { return heap[idx]; }\n\nlet heap_next = heap.length;\n\nfunction dropObject(idx) {\n    if (idx < 36) return;\n    heap[idx] = heap_next;\n    heap_next = idx;\n}\n\nfunction takeObject(idx) {\n    const ret = getObject(idx);\n    dropObject(idx);\n    return ret;\n}\n\nfunction addHeapObject(obj) {\n    if (heap_next === heap.length) heap.push(heap.length + 1);\n    const idx = heap_next;\n    heap_next = heap[idx];\n\n    heap[idx] = obj;\n    return idx;\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nlet cachegetUint8Memory0 = null;\nfunction getUint8Memory0() {\n    if (cachegetUint8Memory0 === null || cachegetUint8Memory0.buffer !== _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"memory\"].buffer) {\n        cachegetUint8Memory0 = new Uint8Array(_sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"memory\"].buffer);\n    }\n    return cachegetUint8Memory0;\n}\n\nconst lTextEncoder = typeof TextEncoder === 'undefined' ? (0, module.require)('util').TextEncoder : TextEncoder;\n\nlet cachedTextEncoder = new lTextEncoder('utf-8');\n\nconst encodeString = (typeof cachedTextEncoder.encodeInto === 'function'\n    ? function (arg, view) {\n    return cachedTextEncoder.encodeInto(arg, view);\n}\n    : function (arg, view) {\n    const buf = cachedTextEncoder.encode(arg);\n    view.set(buf);\n    return {\n        read: arg.length,\n        written: buf.length\n    };\n});\n\nfunction passStringToWasm0(arg, malloc, realloc) {\n\n    if (realloc === undefined) {\n        const buf = cachedTextEncoder.encode(arg);\n        const ptr = malloc(buf.length);\n        getUint8Memory0().subarray(ptr, ptr + buf.length).set(buf);\n        WASM_VECTOR_LEN = buf.length;\n        return ptr;\n    }\n\n    let len = arg.length;\n    let ptr = malloc(len);\n\n    const mem = getUint8Memory0();\n\n    let offset = 0;\n\n    for (; offset < len; offset++) {\n        const code = arg.charCodeAt(offset);\n        if (code > 0x7F) break;\n        mem[ptr + offset] = code;\n    }\n\n    if (offset !== len) {\n        if (offset !== 0) {\n            arg = arg.slice(offset);\n        }\n        ptr = realloc(ptr, len, len = offset + arg.length * 3);\n        const view = getUint8Memory0().subarray(ptr + offset, ptr + len);\n        const ret = encodeString(arg, view);\n\n        offset += ret.written;\n    }\n\n    WASM_VECTOR_LEN = offset;\n    return ptr;\n}\n\nfunction isLikeNone(x) {\n    return x === undefined || x === null;\n}\n\nlet cachegetInt32Memory0 = null;\nfunction getInt32Memory0() {\n    if (cachegetInt32Memory0 === null || cachegetInt32Memory0.buffer !== _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"memory\"].buffer) {\n        cachegetInt32Memory0 = new Int32Array(_sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"memory\"].buffer);\n    }\n    return cachegetInt32Memory0;\n}\n\nfunction debugString(val) {\n    // primitive types\n    const type = typeof val;\n    if (type == 'number' || type == 'boolean' || val == null) {\n        return  `${val}`;\n    }\n    if (type == 'string') {\n        return `\"${val}\"`;\n    }\n    if (type == 'symbol') {\n        const description = val.description;\n        if (description == null) {\n            return 'Symbol';\n        } else {\n            return `Symbol(${description})`;\n        }\n    }\n    if (type == 'function') {\n        const name = val.name;\n        if (typeof name == 'string' && name.length > 0) {\n            return `Function(${name})`;\n        } else {\n            return 'Function';\n        }\n    }\n    // objects\n    if (Array.isArray(val)) {\n        const length = val.length;\n        let debug = '[';\n        if (length > 0) {\n            debug += debugString(val[0]);\n        }\n        for(let i = 1; i < length; i++) {\n            debug += ', ' + debugString(val[i]);\n        }\n        debug += ']';\n        return debug;\n    }\n    // Test for built-in\n    const builtInMatches = /\\[object ([^\\]]+)\\]/.exec(toString.call(val));\n    let className;\n    if (builtInMatches.length > 1) {\n        className = builtInMatches[1];\n    } else {\n        // Failed to match the standard '[object ClassName]'\n        return toString.call(val);\n    }\n    if (className == 'Object') {\n        // we're a user defined class or Object\n        // JSON.stringify avoids problems with cycles, and is generally much\n        // easier than looping through ownProperties of `val`.\n        try {\n            return 'Object(' + JSON.stringify(val) + ')';\n        } catch (_) {\n            return 'Object';\n        }\n    }\n    // errors\n    if (val instanceof Error) {\n        return `${val.name}: ${val.message}\\n${val.stack}`;\n    }\n    // TODO we could test for more things here, like `Set`s and `Map`s.\n    return className;\n}\n\nconst lTextDecoder = typeof TextDecoder === 'undefined' ? (0, module.require)('util').TextDecoder : TextDecoder;\n\nlet cachedTextDecoder = new lTextDecoder('utf-8', { ignoreBOM: true, fatal: true });\n\ncachedTextDecoder.decode();\n\nfunction getStringFromWasm0(ptr, len) {\n    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));\n}\n\nlet stack_pointer = 32;\n\nfunction addBorrowedObject(obj) {\n    if (stack_pointer == 1) throw new Error('out of js stack');\n    heap[--stack_pointer] = obj;\n    return stack_pointer;\n}\n\nconst u32CvtShim = new Uint32Array(2);\n\nconst int64CvtShim = new BigInt64Array(u32CvtShim.buffer);\n/**\n* @param {number} size\n* @param {number} threshold\n* @returns {BigInt}\n*/\nfunction sumvectorfullrust(size, threshold) {\n    _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"sumvectorfullrust\"](8, size, threshold);\n    var r0 = getInt32Memory0()[8 / 4 + 0];\n    var r1 = getInt32Memory0()[8 / 4 + 1];\n    u32CvtShim[0] = r0;\n    u32CvtShim[1] = r1;\n    const n0 = int64CvtShim[0];\n    return n0;\n}\n\nfunction _assertClass(instance, klass) {\n    if (!(instance instanceof klass)) {\n        throw new Error(`expected instance of ${klass.name}`);\n    }\n    return instance.ptr;\n}\n\nfunction handleError(f) {\n    return function () {\n        try {\n            return f.apply(this, arguments);\n\n        } catch (e) {\n            _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbindgen_exn_store\"](addHeapObject(e));\n        }\n    };\n}\n\nfunction getArrayU8FromWasm0(ptr, len) {\n    return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len);\n}\n/**\n* A Sophia `FastDataset` adapter that can be exported to an object that is almost compliant to a\n* [RDF.JS dataset](https://rdf.js.org/dataset-spec/#dataset-interface)\n*/\nclass ArrayDataset {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ArrayDataset.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    free() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbg_arraydataset_free\"](ptr);\n    }\n    /**\n    * Returns a new dataset that contains every quad that matches the passed arguments.\n    * Returns a new dataset that contains every quad that matches the passed arguments.\n    * @param {any} subject\n    * @param {any} predicate\n    * @param {any} object\n    * @param {any} graph\n    * @returns {ArrayDataset}\n    */\n    match(subject, predicate, object, graph) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"arraydataset_match\"](this.ptr, addBorrowedObject(subject), addBorrowedObject(predicate), addBorrowedObject(object), addBorrowedObject(graph));\n            return ArrayDataset.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Constructs an empty `FastDataset` that have a RDF.JS interface.\n    */\n    constructor() {\n        var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"arraydataset_new\"]();\n        return ArrayDataset.__wrap(ret);\n    }\n    /**\n    * Returns a pointer on this object.\n    *\n    * It is used as a way to detect if a javascript object that we received is an exported object by this library.\n    * @returns {number}\n    */\n    get getSophiaDatasetPtr() {\n        var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"arraydataset_get_sophia_dataset_ptr\"](this.ptr);\n        return ret;\n    }\n    /**\n    * Loads the content of a rdf graph formatted following the [TriG syntax](https://www.w3.org/TR/trig/)\n    * @param {string} content\n    */\n    load(content) {\n        var ptr0 = passStringToWasm0(content, _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbindgen_malloc\"], _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbindgen_realloc\"]);\n        var len0 = WASM_VECTOR_LEN;\n        _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"arraydataset_load\"](this.ptr, ptr0, len0);\n    }\n    /**\n    * Returns an array that contains every quads contained by this dataset\n    * @returns {Array<any>}\n    */\n    quads() {\n        var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"arraydataset_quads\"](this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * Returns every term contained by the dataset\n    * @returns {Array<any>}\n    */\n    getTerms() {\n        var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"arraydataset_getTerms\"](this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * Returns the number of quads contained by this dataset\n    * @returns {number}\n    */\n    get size() {\n        var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"arraydataset_get_size\"](this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Returns a javascript style iterator on every quads on this dataset.\n    * @returns {RustExportIterator}\n    */\n    getIterator() {\n        var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"arraydataset_getIterator\"](this.ptr);\n        return RustExportIterator.__wrap(ret);\n    }\n    /**\n    * Adds the given quad to this dataset\n    * @param {any} quad\n    */\n    add(quad) {\n        try {\n            _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"arraydataset_add\"](this.ptr, addBorrowedObject(quad));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Deletes the passed quad from this dataset\n    * @param {any} quad\n    */\n    delete(quad) {\n        try {\n            _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"arraydataset_delete\"](this.ptr, addBorrowedObject(quad));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns `true` if this dataset has the passed quad\n    * @param {any} quad\n    * @returns {boolean}\n    */\n    has(quad) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"arraydataset_has\"](this.ptr, addBorrowedObject(quad));\n            return ret !== 0;\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Adds every quad contained in the passed dataset or sequence\n    * @param {any} quads_as_jsvalue\n    */\n    addAll(quads_as_jsvalue) {\n        try {\n            _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"arraydataset_addAll\"](this.ptr, addBorrowedObject(quads_as_jsvalue));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns true if imported_dataset is contained by this dataset\n    * @param {any} imported_dataset\n    * @returns {boolean}\n    */\n    contains(imported_dataset) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"arraydataset_contains\"](this.ptr, addBorrowedObject(imported_dataset));\n            return ret !== 0;\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Delete every quad that matches the given quad components\n    * @param {any} subject\n    * @param {any} predicate\n    * @param {any} object\n    * @param {any} graph\n    */\n    deleteMatches(subject, predicate, object, graph) {\n        try {\n            _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"arraydataset_deleteMatches\"](this.ptr, addBorrowedObject(subject), addBorrowedObject(predicate), addBorrowedObject(object), addBorrowedObject(graph));\n        } finally {\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns a new dataset which contains the elements of this dataset that are not included in the imported_dataset\n    * @param {any} imported_dataset\n    * @returns {ArrayDataset}\n    */\n    difference(imported_dataset) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"arraydataset_difference\"](this.ptr, addBorrowedObject(imported_dataset));\n            return ArrayDataset.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns true if the two datasets are equals\n    * @param {any} imported_dataset\n    * @returns {boolean}\n    */\n    equals(imported_dataset) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"arraydataset_equals\"](this.ptr, addBorrowedObject(imported_dataset));\n            return ret !== 0;\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns a dataset with the elements that are contained by both dataset\n    * @param {any} imported_dataset\n    * @returns {ArrayDataset}\n    */\n    intersection(imported_dataset) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"arraydataset_intersection\"](this.ptr, addBorrowedObject(imported_dataset));\n            return ArrayDataset.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns a dataset that contains all quads from the two graphs\n    * @param {any} imported_dataset\n    * @returns {ArrayDataset}\n    */\n    union(imported_dataset) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"arraydataset_union\"](this.ptr, addBorrowedObject(imported_dataset));\n            return ArrayDataset.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Produces an action for each quad of the dataset\n    * @param {Function} quad_run_iteratee\n    */\n    forEach(quad_run_iteratee) {\n        try {\n            _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"arraydataset_forEach\"](this.ptr, addBorrowedObject(quad_run_iteratee));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns true if the result of `filter_function` is true for at least\n    * one quad of the dataset\n    * @param {Function} filter_function\n    * @returns {boolean}\n    */\n    some(filter_function) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"arraydataset_some\"](this.ptr, addBorrowedObject(filter_function));\n            return ret !== 0;\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns true if the result of the passed function is true for every\n    * quad of the dataset\n    * @param {Function} filter_function\n    * @returns {boolean}\n    */\n    every(filter_function) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"arraydataset_every\"](this.ptr, addBorrowedObject(filter_function));\n            return ret !== 0;\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns a new dataset which contains every quads of this dataset that\n    * verifies the `filter_functio`\n    * @param {Function} filter_function\n    * @returns {ArrayDataset}\n    */\n    filter(filter_function) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"arraydataset_filter\"](this.ptr, addBorrowedObject(filter_function));\n            return ArrayDataset.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Builds a new dataset which contains quads that have been built by\n    * applying the map function to every quad of this dataset\n    * @param {Function} map_function\n    * @returns {ArrayDataset}\n    */\n    map(map_function) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"arraydataset_map\"](this.ptr, addBorrowedObject(map_function));\n            return ArrayDataset.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns an array that contains every quad contained by this dataset\n    * @returns {Array<any>}\n    */\n    toArray() {\n        var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"arraydataset_toArray\"](this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * Returns a string representation of the quads contained in the dataset\n    * @returns {string}\n    */\n    toString() {\n        try {\n            _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"arraydataset_toString\"](8, this.ptr);\n            var r0 = getInt32Memory0()[8 / 4 + 0];\n            var r1 = getInt32Memory0()[8 / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbindgen_free\"](r0, r1);\n        }\n    }\n    /**\n    * Reduces the whole dataset to a single element\n    *\n    * The behavior of this function matches the `Array.prototype.reduce`\n    * function from EcmaScript.\n    * @param {Function} reducer\n    * @param {any} initial_value\n    * @returns {any}\n    */\n    reduce(reducer, initial_value) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"arraydataset_reduce\"](this.ptr, addHeapObject(reducer), addBorrowedObject(initial_value));\n            return takeObject(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\n/**\n* Wrapper struct for every data factory function\n*/\nclass DataFactory {\n\n    static __wrap(ptr) {\n        const obj = Object.create(DataFactory.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    free() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbg_datafactory_free\"](ptr);\n    }\n    /**\n    * Builds an instance of a factory that builds RDF.JS compliant objects\n    * managed by Sophia\n    */\n    constructor() {\n        var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"datafactory_new\"]();\n        return DataFactory.__wrap(ret);\n    }\n    /**\n    * Returns a named node that concerns the given URL\n    * @param {string} value\n    * @returns {Term}\n    */\n    static namedNode(value) {\n        var ptr0 = passStringToWasm0(value, _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbindgen_malloc\"], _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbindgen_realloc\"]);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"datafactory_namedNode\"](ptr0, len0);\n        return Term.__wrap(ret);\n    }\n    /**\n    * Returns a blank node that either contains the given URL or a randomly\n    * generated ID using Uuid v4\n    * @param {string | undefined} value\n    * @returns {Term}\n    */\n    static blankNode(value) {\n        var ptr0 = isLikeNone(value) ? 0 : passStringToWasm0(value, _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbindgen_malloc\"], _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbindgen_realloc\"]);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"datafactory_blankNode\"](ptr0, len0);\n        return Term.__wrap(ret);\n    }\n    /**\n    * Returns a new ltieral. If `language_or_data` is a Named Node, it will\n    * be used as the datatype. If it is a string formatted using the BCP 47\n    * spefification il will be used as the language. If undefined, it will be\n    * string.\n    * @param {string | undefined} value_string\n    * @param {any} language_or_datatype\n    * @returns {Term}\n    */\n    static literal(value_string, language_or_datatype) {\n        try {\n            var ptr0 = isLikeNone(value_string) ? 0 : passStringToWasm0(value_string, _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbindgen_malloc\"], _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbindgen_realloc\"]);\n            var len0 = WASM_VECTOR_LEN;\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"datafactory_literal\"](ptr0, len0, addBorrowedObject(language_or_datatype));\n            return Term.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Builds a literal using the passed BCP 47 formatted language\n    * @param {string} value\n    * @param {string} language\n    * @returns {Term}\n    */\n    static literalFromString(value, language) {\n        var ptr0 = passStringToWasm0(value, _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbindgen_malloc\"], _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbindgen_realloc\"]);\n        var len0 = WASM_VECTOR_LEN;\n        var ptr1 = passStringToWasm0(language, _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbindgen_malloc\"], _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbindgen_realloc\"]);\n        var len1 = WASM_VECTOR_LEN;\n        var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"datafactory_literalFromString\"](ptr0, len0, ptr1, len1);\n        return Term.__wrap(ret);\n    }\n    /**\n    * Builds a literal of passed the datatype\n    * @param {string} value\n    * @param {any} named_node\n    * @returns {Term}\n    */\n    static literalFromNamedNode(value, named_node) {\n        try {\n            var ptr0 = passStringToWasm0(value, _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbindgen_malloc\"], _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbindgen_realloc\"]);\n            var len0 = WASM_VECTOR_LEN;\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"datafactory_literalFromNamedNode\"](ptr0, len0, addBorrowedObject(named_node));\n            return Term.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Builds a new variable\n    * @param {string | undefined} optional_value\n    * @returns {Term}\n    */\n    static variable(optional_value) {\n        var ptr0 = isLikeNone(optional_value) ? 0 : passStringToWasm0(optional_value, _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbindgen_malloc\"], _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbindgen_realloc\"]);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"datafactory_variable\"](ptr0, len0);\n        return Term.__wrap(ret);\n    }\n    /**\n    * Returns a term that represents the default graph\n    * @returns {Term}\n    */\n    static defaultGraph() {\n        var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"datafactory_defaultGraph\"]();\n        return Term.__wrap(ret);\n    }\n    /**\n    * Retuns a quad managed by Sophia's back end with the given subject,\n    * predicate, object and graph. If no graph is passed, the default graph\n    * will be used.\n    * @param {any} subject\n    * @param {any} predicate\n    * @param {any} object\n    * @param {any} graph\n    * @returns {Quad}\n    */\n    static quad(subject, predicate, object, graph) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"datafactory_quad\"](addBorrowedObject(subject), addBorrowedObject(predicate), addBorrowedObject(object), addBorrowedObject(graph));\n            return Quad.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns a quad managed by Sophia's back end with the given subject,\n    * predicate and object. The assigned graph will be the default graph.\n    * @param {any} subject\n    * @param {any} predicate\n    * @param {any} object\n    * @returns {Quad}\n    */\n    static triple(subject, predicate, object) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"datafactory_triple\"](addBorrowedObject(subject), addBorrowedObject(predicate), addBorrowedObject(object));\n            return Quad.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns a new term managed by Sophia's back end that is identical wrt\n    * RDF.JS specification\n    * @param {any} original\n    * @returns {Term}\n    */\n    static fromTerm(original) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"datafactory_fromTerm\"](addBorrowedObject(original));\n            return Term.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns a new quad managed by Sophia's back end that is identical wrt\n    * RDF.JS specification\n    * @param {any} original\n    * @returns {Quad}\n    */\n    static fromQuad(original) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"datafactory_fromQuad\"](addBorrowedObject(original));\n            return Quad.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns a dataset managed by Sophia's back end. `parameter` can either\n    * be undefined, another dataset or a sequence of quads. If `parameter`\n    * isn't undefined, the returned dataset will contain every quad in the\n    * given argument.\n    * @param {any} parameter\n    * @returns {Datasetcore}\n    */\n    static dataset(parameter) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"datafactory_dataset\"](addBorrowedObject(parameter));\n            return Datasetcore.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\n/**\n* A Sophia `FastDataset` adapter that can be exported to an object that is almost compliant to a\n* [RDF.JS dataset](https://rdf.js.org/dataset-spec/#dataset-interface)\n*/\nclass Datasetcore {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Datasetcore.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    free() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbg_datasetcore_free\"](ptr);\n    }\n    /**\n    * Returns a new dataset that contains every quad that matches the passed arguments.\n    * Returns a new dataset that contains every quad that matches the passed arguments.\n    * @param {any} subject\n    * @param {any} predicate\n    * @param {any} object\n    * @param {any} graph\n    * @returns {Datasetcore}\n    */\n    match(subject, predicate, object, graph) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"datasetcore_match\"](this.ptr, addBorrowedObject(subject), addBorrowedObject(predicate), addBorrowedObject(object), addBorrowedObject(graph));\n            return Datasetcore.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Constructs an empty `FastDataset` that have a RDF.JS interface.\n    */\n    constructor() {\n        var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"datasetcore_new\"]();\n        return Datasetcore.__wrap(ret);\n    }\n    /**\n    * Returns a pointer on this object.\n    *\n    * It is used as a way to detect if a javascript object that we received is an exported object by this library.\n    * @returns {number}\n    */\n    get getSophiaDatasetPtr() {\n        var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"datasetcore_get_sophia_dataset_ptr\"](this.ptr);\n        return ret;\n    }\n    /**\n    * Loads the content of a rdf graph formatted following the [TriG syntax](https://www.w3.org/TR/trig/)\n    * @param {string} content\n    */\n    load(content) {\n        var ptr0 = passStringToWasm0(content, _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbindgen_malloc\"], _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbindgen_realloc\"]);\n        var len0 = WASM_VECTOR_LEN;\n        _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"datasetcore_load\"](this.ptr, ptr0, len0);\n    }\n    /**\n    * Returns an array that contains every quads contained by this dataset\n    * @returns {Array<any>}\n    */\n    quads() {\n        var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"datasetcore_quads\"](this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * Returns every term contained by the dataset\n    * @returns {Array<any>}\n    */\n    getTerms() {\n        var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"datasetcore_getTerms\"](this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * Returns the number of quads contained by this dataset\n    * @returns {number}\n    */\n    get size() {\n        var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"datasetcore_get_size\"](this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Returns a javascript style iterator on every quads on this dataset.\n    * @returns {RustExportIterator}\n    */\n    getIterator() {\n        var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"datasetcore_getIterator\"](this.ptr);\n        return RustExportIterator.__wrap(ret);\n    }\n    /**\n    * Adds the given quad to this dataset\n    * @param {any} quad\n    */\n    add(quad) {\n        try {\n            _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"datasetcore_add\"](this.ptr, addBorrowedObject(quad));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Deletes the passed quad from this dataset\n    * @param {any} quad\n    */\n    delete(quad) {\n        try {\n            _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"datasetcore_delete\"](this.ptr, addBorrowedObject(quad));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns `true` if this dataset has the passed quad\n    * @param {any} quad\n    * @returns {boolean}\n    */\n    has(quad) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"datasetcore_has\"](this.ptr, addBorrowedObject(quad));\n            return ret !== 0;\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Adds every quad contained in the passed dataset or sequence\n    * @param {any} quads_as_jsvalue\n    */\n    addAll(quads_as_jsvalue) {\n        try {\n            _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"datasetcore_addAll\"](this.ptr, addBorrowedObject(quads_as_jsvalue));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns true if imported_dataset is contained by this dataset\n    * @param {any} imported_dataset\n    * @returns {boolean}\n    */\n    contains(imported_dataset) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"datasetcore_contains\"](this.ptr, addBorrowedObject(imported_dataset));\n            return ret !== 0;\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Delete every quad that matches the given quad components\n    * @param {any} subject\n    * @param {any} predicate\n    * @param {any} object\n    * @param {any} graph\n    */\n    deleteMatches(subject, predicate, object, graph) {\n        try {\n            _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"datasetcore_deleteMatches\"](this.ptr, addBorrowedObject(subject), addBorrowedObject(predicate), addBorrowedObject(object), addBorrowedObject(graph));\n        } finally {\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns a new dataset which contains the elements of this dataset that are not included in the imported_dataset\n    * @param {any} imported_dataset\n    * @returns {Datasetcore}\n    */\n    difference(imported_dataset) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"datasetcore_difference\"](this.ptr, addBorrowedObject(imported_dataset));\n            return Datasetcore.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns true if the two datasets are equals\n    * @param {any} imported_dataset\n    * @returns {boolean}\n    */\n    equals(imported_dataset) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"datasetcore_equals\"](this.ptr, addBorrowedObject(imported_dataset));\n            return ret !== 0;\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns a dataset with the elements that are contained by both dataset\n    * @param {any} imported_dataset\n    * @returns {Datasetcore}\n    */\n    intersection(imported_dataset) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"datasetcore_intersection\"](this.ptr, addBorrowedObject(imported_dataset));\n            return Datasetcore.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns a dataset that contains all quads from the two graphs\n    * @param {any} imported_dataset\n    * @returns {Datasetcore}\n    */\n    union(imported_dataset) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"datasetcore_union\"](this.ptr, addBorrowedObject(imported_dataset));\n            return Datasetcore.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Produces an action for each quad of the dataset\n    * @param {Function} quad_run_iteratee\n    */\n    forEach(quad_run_iteratee) {\n        try {\n            _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"datasetcore_forEach\"](this.ptr, addBorrowedObject(quad_run_iteratee));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns true if the result of `filter_function` is true for at least\n    * one quad of the dataset\n    * @param {Function} filter_function\n    * @returns {boolean}\n    */\n    some(filter_function) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"datasetcore_some\"](this.ptr, addBorrowedObject(filter_function));\n            return ret !== 0;\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns true if the result of the passed function is true for every\n    * quad of the dataset\n    * @param {Function} filter_function\n    * @returns {boolean}\n    */\n    every(filter_function) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"datasetcore_every\"](this.ptr, addBorrowedObject(filter_function));\n            return ret !== 0;\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns a new dataset which contains every quads of this dataset that\n    * verifies the `filter_functio`\n    * @param {Function} filter_function\n    * @returns {Datasetcore}\n    */\n    filter(filter_function) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"datasetcore_filter\"](this.ptr, addBorrowedObject(filter_function));\n            return Datasetcore.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Builds a new dataset which contains quads that have been built by\n    * applying the map function to every quad of this dataset\n    * @param {Function} map_function\n    * @returns {Datasetcore}\n    */\n    map(map_function) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"datasetcore_map\"](this.ptr, addBorrowedObject(map_function));\n            return Datasetcore.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns an array that contains every quad contained by this dataset\n    * @returns {Array<any>}\n    */\n    toArray() {\n        var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"datasetcore_toArray\"](this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * Returns a string representation of the quads contained in the dataset\n    * @returns {string}\n    */\n    toString() {\n        try {\n            _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"datasetcore_toString\"](8, this.ptr);\n            var r0 = getInt32Memory0()[8 / 4 + 0];\n            var r1 = getInt32Memory0()[8 / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbindgen_free\"](r0, r1);\n        }\n    }\n    /**\n    * Reduces the whole dataset to a single element\n    *\n    * The behavior of this function matches the `Array.prototype.reduce`\n    * function from EcmaScript.\n    * @param {Function} reducer\n    * @param {any} initial_value\n    * @returns {any}\n    */\n    reduce(reducer, initial_value) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"datasetcore_reduce\"](this.ptr, addHeapObject(reducer), addBorrowedObject(initial_value));\n            return takeObject(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\n/**\n* A Sophia `FastDataset` adapter that can be exported to an object that is almost compliant to a\n* [RDF.JS dataset](https://rdf.js.org/dataset-spec/#dataset-interface)\n*/\nclass FastDataset {\n\n    static __wrap(ptr) {\n        const obj = Object.create(FastDataset.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    free() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbg_fastdataset_free\"](ptr);\n    }\n    /**\n    * Returns a new dataset that contains every quad that matches the passed arguments.\n    * Returns a new dataset that contains every quad that matches the passed arguments.\n    * @param {any} subject\n    * @param {any} predicate\n    * @param {any} object\n    * @param {any} graph\n    * @returns {FastDataset}\n    */\n    match(subject, predicate, object, graph) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fastdataset_match\"](this.ptr, addBorrowedObject(subject), addBorrowedObject(predicate), addBorrowedObject(object), addBorrowedObject(graph));\n            return FastDataset.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Constructs an empty `FastDataset` that have a RDF.JS interface.\n    */\n    constructor() {\n        var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fastdataset_new\"]();\n        return FastDataset.__wrap(ret);\n    }\n    /**\n    * Returns a pointer on this object.\n    *\n    * It is used as a way to detect if a javascript object that we received is an exported object by this library.\n    * @returns {number}\n    */\n    get getSophiaDatasetPtr() {\n        var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"datasetcore_get_sophia_dataset_ptr\"](this.ptr);\n        return ret;\n    }\n    /**\n    * Loads the content of a rdf graph formatted following the [TriG syntax](https://www.w3.org/TR/trig/)\n    * @param {string} content\n    */\n    load(content) {\n        var ptr0 = passStringToWasm0(content, _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbindgen_malloc\"], _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbindgen_realloc\"]);\n        var len0 = WASM_VECTOR_LEN;\n        _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fastdataset_load\"](this.ptr, ptr0, len0);\n    }\n    /**\n    * Returns an array that contains every quads contained by this dataset\n    * @returns {Array<any>}\n    */\n    quads() {\n        var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fastdataset_quads\"](this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * Returns every term contained by the dataset\n    * @returns {Array<any>}\n    */\n    getTerms() {\n        var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fastdataset_getTerms\"](this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * Returns the number of quads contained by this dataset\n    * @returns {number}\n    */\n    get size() {\n        var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fastdataset_get_size\"](this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Returns a javascript style iterator on every quads on this dataset.\n    * @returns {RustExportIterator}\n    */\n    getIterator() {\n        var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fastdataset_getIterator\"](this.ptr);\n        return RustExportIterator.__wrap(ret);\n    }\n    /**\n    * Adds the given quad to this dataset\n    * @param {any} quad\n    */\n    add(quad) {\n        try {\n            _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fastdataset_add\"](this.ptr, addBorrowedObject(quad));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Deletes the passed quad from this dataset\n    * @param {any} quad\n    */\n    delete(quad) {\n        try {\n            _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fastdataset_delete\"](this.ptr, addBorrowedObject(quad));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns `true` if this dataset has the passed quad\n    * @param {any} quad\n    * @returns {boolean}\n    */\n    has(quad) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fastdataset_has\"](this.ptr, addBorrowedObject(quad));\n            return ret !== 0;\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Adds every quad contained in the passed dataset or sequence\n    * @param {any} quads_as_jsvalue\n    */\n    addAll(quads_as_jsvalue) {\n        try {\n            _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fastdataset_addAll\"](this.ptr, addBorrowedObject(quads_as_jsvalue));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns true if imported_dataset is contained by this dataset\n    * @param {any} imported_dataset\n    * @returns {boolean}\n    */\n    contains(imported_dataset) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fastdataset_contains\"](this.ptr, addBorrowedObject(imported_dataset));\n            return ret !== 0;\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Delete every quad that matches the given quad components\n    * @param {any} subject\n    * @param {any} predicate\n    * @param {any} object\n    * @param {any} graph\n    */\n    deleteMatches(subject, predicate, object, graph) {\n        try {\n            _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fastdataset_deleteMatches\"](this.ptr, addBorrowedObject(subject), addBorrowedObject(predicate), addBorrowedObject(object), addBorrowedObject(graph));\n        } finally {\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns a new dataset which contains the elements of this dataset that are not included in the imported_dataset\n    * @param {any} imported_dataset\n    * @returns {FastDataset}\n    */\n    difference(imported_dataset) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fastdataset_difference\"](this.ptr, addBorrowedObject(imported_dataset));\n            return FastDataset.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns true if the two datasets are equals\n    * @param {any} imported_dataset\n    * @returns {boolean}\n    */\n    equals(imported_dataset) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fastdataset_equals\"](this.ptr, addBorrowedObject(imported_dataset));\n            return ret !== 0;\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns a dataset with the elements that are contained by both dataset\n    * @param {any} imported_dataset\n    * @returns {FastDataset}\n    */\n    intersection(imported_dataset) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fastdataset_intersection\"](this.ptr, addBorrowedObject(imported_dataset));\n            return FastDataset.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns a dataset that contains all quads from the two graphs\n    * @param {any} imported_dataset\n    * @returns {FastDataset}\n    */\n    union(imported_dataset) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fastdataset_union\"](this.ptr, addBorrowedObject(imported_dataset));\n            return FastDataset.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Produces an action for each quad of the dataset\n    * @param {Function} quad_run_iteratee\n    */\n    forEach(quad_run_iteratee) {\n        try {\n            _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fastdataset_forEach\"](this.ptr, addBorrowedObject(quad_run_iteratee));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns true if the result of `filter_function` is true for at least\n    * one quad of the dataset\n    * @param {Function} filter_function\n    * @returns {boolean}\n    */\n    some(filter_function) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fastdataset_some\"](this.ptr, addBorrowedObject(filter_function));\n            return ret !== 0;\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns true if the result of the passed function is true for every\n    * quad of the dataset\n    * @param {Function} filter_function\n    * @returns {boolean}\n    */\n    every(filter_function) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fastdataset_every\"](this.ptr, addBorrowedObject(filter_function));\n            return ret !== 0;\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns a new dataset which contains every quads of this dataset that\n    * verifies the `filter_functio`\n    * @param {Function} filter_function\n    * @returns {FastDataset}\n    */\n    filter(filter_function) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fastdataset_filter\"](this.ptr, addBorrowedObject(filter_function));\n            return FastDataset.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Builds a new dataset which contains quads that have been built by\n    * applying the map function to every quad of this dataset\n    * @param {Function} map_function\n    * @returns {FastDataset}\n    */\n    map(map_function) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fastdataset_map\"](this.ptr, addBorrowedObject(map_function));\n            return FastDataset.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns an array that contains every quad contained by this dataset\n    * @returns {Array<any>}\n    */\n    toArray() {\n        var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fastdataset_toArray\"](this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * Returns a string representation of the quads contained in the dataset\n    * @returns {string}\n    */\n    toString() {\n        try {\n            _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fastdataset_toString\"](8, this.ptr);\n            var r0 = getInt32Memory0()[8 / 4 + 0];\n            var r1 = getInt32Memory0()[8 / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbindgen_free\"](r0, r1);\n        }\n    }\n    /**\n    * Reduces the whole dataset to a single element\n    *\n    * The behavior of this function matches the `Array.prototype.reduce`\n    * function from EcmaScript.\n    * @param {Function} reducer\n    * @param {any} initial_value\n    * @returns {any}\n    */\n    reduce(reducer, initial_value) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fastdataset_reduce\"](this.ptr, addHeapObject(reducer), addBorrowedObject(initial_value));\n            return takeObject(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\n/**\n* A Sophia `FastDataset` adapter that can be exported to an object that is almost compliant to a\n* [RDF.JS dataset](https://rdf.js.org/dataset-spec/#dataset-interface)\n*/\nclass FastDatasetToA {\n\n    static __wrap(ptr) {\n        const obj = Object.create(FastDatasetToA.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    free() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbg_fastdatasettoa_free\"](ptr);\n    }\n    /**\n    * Returns a new dataset that contains every quad that matches the passed arguments.\n    * Returns a new dataset that contains every quad that matches the passed arguments.\n    * @param {any} subject\n    * @param {any} predicate\n    * @param {any} object\n    * @param {any} graph\n    * @returns {ArrayDataset}\n    */\n    match(subject, predicate, object, graph) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fastdatasettoa_match\"](this.ptr, addBorrowedObject(subject), addBorrowedObject(predicate), addBorrowedObject(object), addBorrowedObject(graph));\n            return ArrayDataset.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Constructs an empty `FastDataset` that have a RDF.JS interface.\n    */\n    constructor() {\n        var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fastdataset_new\"]();\n        return FastDatasetToA.__wrap(ret);\n    }\n    /**\n    * Returns a pointer on this object.\n    *\n    * It is used as a way to detect if a javascript object that we received is an exported object by this library.\n    * @returns {number}\n    */\n    get getSophiaDatasetPtr() {\n        var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"datasetcore_get_sophia_dataset_ptr\"](this.ptr);\n        return ret;\n    }\n    /**\n    * Loads the content of a rdf graph formatted following the [TriG syntax](https://www.w3.org/TR/trig/)\n    * @param {string} content\n    */\n    load(content) {\n        var ptr0 = passStringToWasm0(content, _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbindgen_malloc\"], _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbindgen_realloc\"]);\n        var len0 = WASM_VECTOR_LEN;\n        _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fastdatasettoa_load\"](this.ptr, ptr0, len0);\n    }\n    /**\n    * Returns an array that contains every quads contained by this dataset\n    * @returns {Array<any>}\n    */\n    quads() {\n        var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fastdatasettoa_quads\"](this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * Returns every term contained by the dataset\n    * @returns {Array<any>}\n    */\n    getTerms() {\n        var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fastdatasettoa_getTerms\"](this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * Returns the number of quads contained by this dataset\n    * @returns {number}\n    */\n    get size() {\n        var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fastdataset_get_size\"](this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Returns a javascript style iterator on every quads on this dataset.\n    * @returns {RustExportIterator}\n    */\n    getIterator() {\n        var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fastdatasettoa_getIterator\"](this.ptr);\n        return RustExportIterator.__wrap(ret);\n    }\n    /**\n    * Adds the given quad to this dataset\n    * @param {any} quad\n    */\n    add(quad) {\n        try {\n            _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fastdatasettoa_add\"](this.ptr, addBorrowedObject(quad));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Deletes the passed quad from this dataset\n    * @param {any} quad\n    */\n    delete(quad) {\n        try {\n            _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fastdataset_delete\"](this.ptr, addBorrowedObject(quad));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns `true` if this dataset has the passed quad\n    * @param {any} quad\n    * @returns {boolean}\n    */\n    has(quad) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fastdataset_has\"](this.ptr, addBorrowedObject(quad));\n            return ret !== 0;\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Adds every quad contained in the passed dataset or sequence\n    * @param {any} quads_as_jsvalue\n    */\n    addAll(quads_as_jsvalue) {\n        try {\n            _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fastdatasettoa_addAll\"](this.ptr, addBorrowedObject(quads_as_jsvalue));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns true if imported_dataset is contained by this dataset\n    * @param {any} imported_dataset\n    * @returns {boolean}\n    */\n    contains(imported_dataset) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fastdatasettoa_contains\"](this.ptr, addBorrowedObject(imported_dataset));\n            return ret !== 0;\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Delete every quad that matches the given quad components\n    * @param {any} subject\n    * @param {any} predicate\n    * @param {any} object\n    * @param {any} graph\n    */\n    deleteMatches(subject, predicate, object, graph) {\n        try {\n            _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fastdataset_deleteMatches\"](this.ptr, addBorrowedObject(subject), addBorrowedObject(predicate), addBorrowedObject(object), addBorrowedObject(graph));\n        } finally {\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns a new dataset which contains the elements of this dataset that are not included in the imported_dataset\n    * @param {any} imported_dataset\n    * @returns {FastDatasetToA}\n    */\n    difference(imported_dataset) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fastdatasettoa_difference\"](this.ptr, addBorrowedObject(imported_dataset));\n            return FastDatasetToA.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns true if the two datasets are equals\n    * @param {any} imported_dataset\n    * @returns {boolean}\n    */\n    equals(imported_dataset) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fastdatasettoa_equals\"](this.ptr, addBorrowedObject(imported_dataset));\n            return ret !== 0;\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns a dataset with the elements that are contained by both dataset\n    * @param {any} imported_dataset\n    * @returns {FastDatasetToA}\n    */\n    intersection(imported_dataset) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fastdatasettoa_intersection\"](this.ptr, addBorrowedObject(imported_dataset));\n            return FastDatasetToA.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns a dataset that contains all quads from the two graphs\n    * @param {any} imported_dataset\n    * @returns {FastDatasetToA}\n    */\n    union(imported_dataset) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fastdatasettoa_union\"](this.ptr, addBorrowedObject(imported_dataset));\n            return FastDatasetToA.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Produces an action for each quad of the dataset\n    * @param {Function} quad_run_iteratee\n    */\n    forEach(quad_run_iteratee) {\n        try {\n            _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fastdatasettoa_forEach\"](this.ptr, addBorrowedObject(quad_run_iteratee));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns true if the result of `filter_function` is true for at least\n    * one quad of the dataset\n    * @param {Function} filter_function\n    * @returns {boolean}\n    */\n    some(filter_function) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fastdatasettoa_some\"](this.ptr, addBorrowedObject(filter_function));\n            return ret !== 0;\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns true if the result of the passed function is true for every\n    * quad of the dataset\n    * @param {Function} filter_function\n    * @returns {boolean}\n    */\n    every(filter_function) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fastdatasettoa_every\"](this.ptr, addBorrowedObject(filter_function));\n            return ret !== 0;\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns a new dataset which contains every quads of this dataset that\n    * verifies the `filter_functio`\n    * @param {Function} filter_function\n    * @returns {FastDatasetToA}\n    */\n    filter(filter_function) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fastdatasettoa_filter\"](this.ptr, addBorrowedObject(filter_function));\n            return FastDatasetToA.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Builds a new dataset which contains quads that have been built by\n    * applying the map function to every quad of this dataset\n    * @param {Function} map_function\n    * @returns {FastDatasetToA}\n    */\n    map(map_function) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fastdatasettoa_map\"](this.ptr, addBorrowedObject(map_function));\n            return FastDatasetToA.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns an array that contains every quad contained by this dataset\n    * @returns {Array<any>}\n    */\n    toArray() {\n        var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fastdatasettoa_toArray\"](this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * Returns a string representation of the quads contained in the dataset\n    * @returns {string}\n    */\n    toString() {\n        try {\n            _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fastdatasettoa_toString\"](8, this.ptr);\n            var r0 = getInt32Memory0()[8 / 4 + 0];\n            var r1 = getInt32Memory0()[8 / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbindgen_free\"](r0, r1);\n        }\n    }\n    /**\n    * Reduces the whole dataset to a single element\n    *\n    * The behavior of this function matches the `Array.prototype.reduce`\n    * function from EcmaScript.\n    * @param {Function} reducer\n    * @param {any} initial_value\n    * @returns {any}\n    */\n    reduce(reducer, initial_value) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fastdatasettoa_reduce\"](this.ptr, addHeapObject(reducer), addBorrowedObject(initial_value));\n            return takeObject(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\n/**\n* A Sophia `FastDataset` adapter that can be exported to an object that is almost compliant to a\n* [RDF.JS dataset](https://rdf.js.org/dataset-spec/#dataset-interface)\n*/\nclass FullDataset {\n\n    static __wrap(ptr) {\n        const obj = Object.create(FullDataset.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    free() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbg_fulldataset_free\"](ptr);\n    }\n    /**\n    * Returns a new dataset that contains every quad that matches the passed arguments.\n    * Returns a new dataset that contains every quad that matches the passed arguments.\n    * @param {any} subject\n    * @param {any} predicate\n    * @param {any} object\n    * @param {any} graph\n    * @returns {FullDataset}\n    */\n    match(subject, predicate, object, graph) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fulldataset_match\"](this.ptr, addBorrowedObject(subject), addBorrowedObject(predicate), addBorrowedObject(object), addBorrowedObject(graph));\n            return FullDataset.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Constructs an empty `FastDataset` that have a RDF.JS interface.\n    */\n    constructor() {\n        var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fulldataset_new\"]();\n        return FullDataset.__wrap(ret);\n    }\n    /**\n    * Returns a pointer on this object.\n    *\n    * It is used as a way to detect if a javascript object that we received is an exported object by this library.\n    * @returns {number}\n    */\n    get getSophiaDatasetPtr() {\n        var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"datasetcore_get_sophia_dataset_ptr\"](this.ptr);\n        return ret;\n    }\n    /**\n    * Loads the content of a rdf graph formatted following the [TriG syntax](https://www.w3.org/TR/trig/)\n    * @param {string} content\n    */\n    load(content) {\n        var ptr0 = passStringToWasm0(content, _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbindgen_malloc\"], _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbindgen_realloc\"]);\n        var len0 = WASM_VECTOR_LEN;\n        _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fulldataset_load\"](this.ptr, ptr0, len0);\n    }\n    /**\n    * Returns an array that contains every quads contained by this dataset\n    * @returns {Array<any>}\n    */\n    quads() {\n        var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fulldataset_quads\"](this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * Returns every term contained by the dataset\n    * @returns {Array<any>}\n    */\n    getTerms() {\n        var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fulldataset_getTerms\"](this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * Returns the number of quads contained by this dataset\n    * @returns {number}\n    */\n    get size() {\n        var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fulldataset_get_size\"](this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Returns a javascript style iterator on every quads on this dataset.\n    * @returns {RustExportIterator}\n    */\n    getIterator() {\n        var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fulldataset_getIterator\"](this.ptr);\n        return RustExportIterator.__wrap(ret);\n    }\n    /**\n    * Adds the given quad to this dataset\n    * @param {any} quad\n    */\n    add(quad) {\n        try {\n            _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fulldataset_add\"](this.ptr, addBorrowedObject(quad));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Deletes the passed quad from this dataset\n    * @param {any} quad\n    */\n    delete(quad) {\n        try {\n            _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fulldataset_delete\"](this.ptr, addBorrowedObject(quad));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns `true` if this dataset has the passed quad\n    * @param {any} quad\n    * @returns {boolean}\n    */\n    has(quad) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fulldataset_has\"](this.ptr, addBorrowedObject(quad));\n            return ret !== 0;\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Adds every quad contained in the passed dataset or sequence\n    * @param {any} quads_as_jsvalue\n    */\n    addAll(quads_as_jsvalue) {\n        try {\n            _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fulldataset_addAll\"](this.ptr, addBorrowedObject(quads_as_jsvalue));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns true if imported_dataset is contained by this dataset\n    * @param {any} imported_dataset\n    * @returns {boolean}\n    */\n    contains(imported_dataset) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fulldataset_contains\"](this.ptr, addBorrowedObject(imported_dataset));\n            return ret !== 0;\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Delete every quad that matches the given quad components\n    * @param {any} subject\n    * @param {any} predicate\n    * @param {any} object\n    * @param {any} graph\n    */\n    deleteMatches(subject, predicate, object, graph) {\n        try {\n            _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fulldataset_deleteMatches\"](this.ptr, addBorrowedObject(subject), addBorrowedObject(predicate), addBorrowedObject(object), addBorrowedObject(graph));\n        } finally {\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns a new dataset which contains the elements of this dataset that are not included in the imported_dataset\n    * @param {any} imported_dataset\n    * @returns {FullDataset}\n    */\n    difference(imported_dataset) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fulldataset_difference\"](this.ptr, addBorrowedObject(imported_dataset));\n            return FullDataset.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns true if the two datasets are equals\n    * @param {any} imported_dataset\n    * @returns {boolean}\n    */\n    equals(imported_dataset) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fulldataset_equals\"](this.ptr, addBorrowedObject(imported_dataset));\n            return ret !== 0;\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns a dataset with the elements that are contained by both dataset\n    * @param {any} imported_dataset\n    * @returns {FullDataset}\n    */\n    intersection(imported_dataset) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fulldataset_intersection\"](this.ptr, addBorrowedObject(imported_dataset));\n            return FullDataset.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns a dataset that contains all quads from the two graphs\n    * @param {any} imported_dataset\n    * @returns {FullDataset}\n    */\n    union(imported_dataset) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fulldataset_union\"](this.ptr, addBorrowedObject(imported_dataset));\n            return FullDataset.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Produces an action for each quad of the dataset\n    * @param {Function} quad_run_iteratee\n    */\n    forEach(quad_run_iteratee) {\n        try {\n            _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fulldataset_forEach\"](this.ptr, addBorrowedObject(quad_run_iteratee));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns true if the result of `filter_function` is true for at least\n    * one quad of the dataset\n    * @param {Function} filter_function\n    * @returns {boolean}\n    */\n    some(filter_function) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fulldataset_some\"](this.ptr, addBorrowedObject(filter_function));\n            return ret !== 0;\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns true if the result of the passed function is true for every\n    * quad of the dataset\n    * @param {Function} filter_function\n    * @returns {boolean}\n    */\n    every(filter_function) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fulldataset_every\"](this.ptr, addBorrowedObject(filter_function));\n            return ret !== 0;\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns a new dataset which contains every quads of this dataset that\n    * verifies the `filter_functio`\n    * @param {Function} filter_function\n    * @returns {FullDataset}\n    */\n    filter(filter_function) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fulldataset_filter\"](this.ptr, addBorrowedObject(filter_function));\n            return FullDataset.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Builds a new dataset which contains quads that have been built by\n    * applying the map function to every quad of this dataset\n    * @param {Function} map_function\n    * @returns {FullDataset}\n    */\n    map(map_function) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fulldataset_map\"](this.ptr, addBorrowedObject(map_function));\n            return FullDataset.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns an array that contains every quad contained by this dataset\n    * @returns {Array<any>}\n    */\n    toArray() {\n        var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fulldataset_toArray\"](this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * Returns a string representation of the quads contained in the dataset\n    * @returns {string}\n    */\n    toString() {\n        try {\n            _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fulldataset_toString\"](8, this.ptr);\n            var r0 = getInt32Memory0()[8 / 4 + 0];\n            var r1 = getInt32Memory0()[8 / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbindgen_free\"](r0, r1);\n        }\n    }\n    /**\n    * Reduces the whole dataset to a single element\n    *\n    * The behavior of this function matches the `Array.prototype.reduce`\n    * function from EcmaScript.\n    * @param {Function} reducer\n    * @param {any} initial_value\n    * @returns {any}\n    */\n    reduce(reducer, initial_value) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fulldataset_reduce\"](this.ptr, addHeapObject(reducer), addBorrowedObject(initial_value));\n            return takeObject(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\n/**\n* A Sophia `FastDataset` adapter that can be exported to an object that is almost compliant to a\n* [RDF.JS dataset](https://rdf.js.org/dataset-spec/#dataset-interface)\n*/\nclass FullDatasetToA {\n\n    static __wrap(ptr) {\n        const obj = Object.create(FullDatasetToA.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    free() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbg_fulldatasettoa_free\"](ptr);\n    }\n    /**\n    * Returns a new dataset that contains every quad that matches the passed arguments.\n    * Returns a new dataset that contains every quad that matches the passed arguments.\n    * @param {any} subject\n    * @param {any} predicate\n    * @param {any} object\n    * @param {any} graph\n    * @returns {ArrayDataset}\n    */\n    match(subject, predicate, object, graph) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fulldatasettoa_match\"](this.ptr, addBorrowedObject(subject), addBorrowedObject(predicate), addBorrowedObject(object), addBorrowedObject(graph));\n            return ArrayDataset.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Constructs an empty `FastDataset` that have a RDF.JS interface.\n    */\n    constructor() {\n        var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fulldataset_new\"]();\n        return FullDatasetToA.__wrap(ret);\n    }\n    /**\n    * Returns a pointer on this object.\n    *\n    * It is used as a way to detect if a javascript object that we received is an exported object by this library.\n    * @returns {number}\n    */\n    get getSophiaDatasetPtr() {\n        var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"datasetcore_get_sophia_dataset_ptr\"](this.ptr);\n        return ret;\n    }\n    /**\n    * Loads the content of a rdf graph formatted following the [TriG syntax](https://www.w3.org/TR/trig/)\n    * @param {string} content\n    */\n    load(content) {\n        var ptr0 = passStringToWasm0(content, _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbindgen_malloc\"], _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbindgen_realloc\"]);\n        var len0 = WASM_VECTOR_LEN;\n        _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fulldatasettoa_load\"](this.ptr, ptr0, len0);\n    }\n    /**\n    * Returns an array that contains every quads contained by this dataset\n    * @returns {Array<any>}\n    */\n    quads() {\n        var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fulldatasettoa_quads\"](this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * Returns every term contained by the dataset\n    * @returns {Array<any>}\n    */\n    getTerms() {\n        var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fulldatasettoa_getTerms\"](this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * Returns the number of quads contained by this dataset\n    * @returns {number}\n    */\n    get size() {\n        var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fulldatasettoa_get_size\"](this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Returns a javascript style iterator on every quads on this dataset.\n    * @returns {RustExportIterator}\n    */\n    getIterator() {\n        var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fulldatasettoa_getIterator\"](this.ptr);\n        return RustExportIterator.__wrap(ret);\n    }\n    /**\n    * Adds the given quad to this dataset\n    * @param {any} quad\n    */\n    add(quad) {\n        try {\n            _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fulldatasettoa_add\"](this.ptr, addBorrowedObject(quad));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Deletes the passed quad from this dataset\n    * @param {any} quad\n    */\n    delete(quad) {\n        try {\n            _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fulldataset_delete\"](this.ptr, addBorrowedObject(quad));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns `true` if this dataset has the passed quad\n    * @param {any} quad\n    * @returns {boolean}\n    */\n    has(quad) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fulldatasettoa_has\"](this.ptr, addBorrowedObject(quad));\n            return ret !== 0;\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Adds every quad contained in the passed dataset or sequence\n    * @param {any} quads_as_jsvalue\n    */\n    addAll(quads_as_jsvalue) {\n        try {\n            _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fulldatasettoa_addAll\"](this.ptr, addBorrowedObject(quads_as_jsvalue));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns true if imported_dataset is contained by this dataset\n    * @param {any} imported_dataset\n    * @returns {boolean}\n    */\n    contains(imported_dataset) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fulldatasettoa_contains\"](this.ptr, addBorrowedObject(imported_dataset));\n            return ret !== 0;\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Delete every quad that matches the given quad components\n    * @param {any} subject\n    * @param {any} predicate\n    * @param {any} object\n    * @param {any} graph\n    */\n    deleteMatches(subject, predicate, object, graph) {\n        try {\n            _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fulldataset_deleteMatches\"](this.ptr, addBorrowedObject(subject), addBorrowedObject(predicate), addBorrowedObject(object), addBorrowedObject(graph));\n        } finally {\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns a new dataset which contains the elements of this dataset that are not included in the imported_dataset\n    * @param {any} imported_dataset\n    * @returns {FullDatasetToA}\n    */\n    difference(imported_dataset) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fulldatasettoa_difference\"](this.ptr, addBorrowedObject(imported_dataset));\n            return FullDatasetToA.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns true if the two datasets are equals\n    * @param {any} imported_dataset\n    * @returns {boolean}\n    */\n    equals(imported_dataset) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fulldatasettoa_equals\"](this.ptr, addBorrowedObject(imported_dataset));\n            return ret !== 0;\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns a dataset with the elements that are contained by both dataset\n    * @param {any} imported_dataset\n    * @returns {FullDatasetToA}\n    */\n    intersection(imported_dataset) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fulldatasettoa_intersection\"](this.ptr, addBorrowedObject(imported_dataset));\n            return FullDatasetToA.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns a dataset that contains all quads from the two graphs\n    * @param {any} imported_dataset\n    * @returns {FullDatasetToA}\n    */\n    union(imported_dataset) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fulldatasettoa_union\"](this.ptr, addBorrowedObject(imported_dataset));\n            return FullDatasetToA.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Produces an action for each quad of the dataset\n    * @param {Function} quad_run_iteratee\n    */\n    forEach(quad_run_iteratee) {\n        try {\n            _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fulldatasettoa_forEach\"](this.ptr, addBorrowedObject(quad_run_iteratee));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns true if the result of `filter_function` is true for at least\n    * one quad of the dataset\n    * @param {Function} filter_function\n    * @returns {boolean}\n    */\n    some(filter_function) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fulldatasettoa_some\"](this.ptr, addBorrowedObject(filter_function));\n            return ret !== 0;\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns true if the result of the passed function is true for every\n    * quad of the dataset\n    * @param {Function} filter_function\n    * @returns {boolean}\n    */\n    every(filter_function) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fulldatasettoa_every\"](this.ptr, addBorrowedObject(filter_function));\n            return ret !== 0;\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns a new dataset which contains every quads of this dataset that\n    * verifies the `filter_functio`\n    * @param {Function} filter_function\n    * @returns {FullDatasetToA}\n    */\n    filter(filter_function) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fulldatasettoa_filter\"](this.ptr, addBorrowedObject(filter_function));\n            return FullDatasetToA.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Builds a new dataset which contains quads that have been built by\n    * applying the map function to every quad of this dataset\n    * @param {Function} map_function\n    * @returns {FullDatasetToA}\n    */\n    map(map_function) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fulldatasettoa_map\"](this.ptr, addBorrowedObject(map_function));\n            return FullDatasetToA.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns an array that contains every quad contained by this dataset\n    * @returns {Array<any>}\n    */\n    toArray() {\n        var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fulldatasettoa_toArray\"](this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * Returns a string representation of the quads contained in the dataset\n    * @returns {string}\n    */\n    toString() {\n        try {\n            _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fulldatasettoa_toString\"](8, this.ptr);\n            var r0 = getInt32Memory0()[8 / 4 + 0];\n            var r1 = getInt32Memory0()[8 / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbindgen_free\"](r0, r1);\n        }\n    }\n    /**\n    * Reduces the whole dataset to a single element\n    *\n    * The behavior of this function matches the `Array.prototype.reduce`\n    * function from EcmaScript.\n    * @param {Function} reducer\n    * @param {any} initial_value\n    * @returns {any}\n    */\n    reduce(reducer, initial_value) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fulldatasettoa_reduce\"](this.ptr, addHeapObject(reducer), addBorrowedObject(initial_value));\n            return takeObject(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\n/**\n*/\nclass IntTree {\n\n    static __wrap(ptr) {\n        const obj = Object.create(IntTree.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    free() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbg_inttree_free\"](ptr);\n    }\n    /**\n    */\n    constructor() {\n        var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"inttree_new\"]();\n        return IntTree.__wrap(ret);\n    }\n    /**\n    * @param {IntVector} vect\n    * @returns {IntTree}\n    */\n    static using(vect) {\n        _assertClass(vect, IntVector);\n        var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"inttree_using\"](vect.ptr);\n        return IntTree.__wrap(ret);\n    }\n    /**\n    * @param {IntTree} other\n    * @returns {IntTree}\n    */\n    static copy(other) {\n        _assertClass(other, IntTree);\n        var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"inttree_copy\"](other.ptr);\n        return IntTree.__wrap(ret);\n    }\n    /**\n    * @returns {BigInt}\n    */\n    sum_inf_to_v() {\n        _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"inttree_sum_inf_to_v\"](8, this.ptr);\n        var r0 = getInt32Memory0()[8 / 4 + 0];\n        var r1 = getInt32Memory0()[8 / 4 + 1];\n        u32CvtShim[0] = r0;\n        u32CvtShim[1] = r1;\n        const n0 = int64CvtShim[0];\n        return n0;\n    }\n    /**\n    * @returns {BigInt}\n    */\n    sum_inf_to_t() {\n        _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"inttree_sum_inf_to_t\"](8, this.ptr);\n        var r0 = getInt32Memory0()[8 / 4 + 0];\n        var r1 = getInt32Memory0()[8 / 4 + 1];\n        u32CvtShim[0] = r0;\n        u32CvtShim[1] = r1;\n        const n0 = int64CvtShim[0];\n        return n0;\n    }\n    /**\n    * @param {RandomValues} random_values\n    */\n    fill_with_v(random_values) {\n        _assertClass(random_values, RandomValues);\n        _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"inttree_fill_with_v\"](this.ptr, random_values.ptr);\n    }\n}\n/**\n*/\nclass IntVector {\n\n    static __wrap(ptr) {\n        const obj = Object.create(IntVector.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    free() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbg_intvector_free\"](ptr);\n    }\n    /**\n    */\n    constructor() {\n        var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"intvector_new\"]();\n        return IntVector.__wrap(ret);\n    }\n    /**\n    * @param {IntTree} tree\n    * @returns {IntVector}\n    */\n    static using(tree) {\n        _assertClass(tree, IntTree);\n        var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"intvector_using\"](tree.ptr);\n        return IntVector.__wrap(ret);\n    }\n    /**\n    * @param {RandomValues} random_values\n    */\n    fill_with_v(random_values) {\n        _assertClass(random_values, RandomValues);\n        _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"intvector_fill_with_v\"](this.ptr, random_values.ptr);\n    }\n    /**\n    * @param {IntVector} other\n    * @returns {IntVector}\n    */\n    static copy(other) {\n        _assertClass(other, IntVector);\n        var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"intvector_copy\"](other.ptr);\n        return IntVector.__wrap(ret);\n    }\n    /**\n    * @returns {BigInt}\n    */\n    sum_inf_to_v() {\n        _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"intvector_sum_inf_to_v\"](8, this.ptr);\n        var r0 = getInt32Memory0()[8 / 4 + 0];\n        var r1 = getInt32Memory0()[8 / 4 + 1];\n        u32CvtShim[0] = r0;\n        u32CvtShim[1] = r1;\n        const n0 = int64CvtShim[0];\n        return n0;\n    }\n    /**\n    * @returns {BigInt}\n    */\n    sum_inf_to_t() {\n        _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"intvector_sum_inf_to_t\"](8, this.ptr);\n        var r0 = getInt32Memory0()[8 / 4 + 0];\n        var r1 = getInt32Memory0()[8 / 4 + 1];\n        u32CvtShim[0] = r0;\n        u32CvtShim[1] = r1;\n        const n0 = int64CvtShim[0];\n        return n0;\n    }\n}\n/**\n* A Sophia `FastDataset` adapter that can be exported to an object that is almost compliant to a\n* [RDF.JS dataset](https://rdf.js.org/dataset-spec/#dataset-interface)\n*/\nclass LightDataset {\n\n    static __wrap(ptr) {\n        const obj = Object.create(LightDataset.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    free() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbg_lightdataset_free\"](ptr);\n    }\n    /**\n    * Returns a new dataset that contains every quad that matches the passed arguments.\n    * Returns a new dataset that contains every quad that matches the passed arguments.\n    * @param {any} subject\n    * @param {any} predicate\n    * @param {any} object\n    * @param {any} graph\n    * @returns {LightDataset}\n    */\n    match(subject, predicate, object, graph) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"lightdataset_match\"](this.ptr, addBorrowedObject(subject), addBorrowedObject(predicate), addBorrowedObject(object), addBorrowedObject(graph));\n            return LightDataset.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Constructs an empty `FastDataset` that have a RDF.JS interface.\n    */\n    constructor() {\n        var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"lightdataset_new\"]();\n        return LightDataset.__wrap(ret);\n    }\n    /**\n    * Returns a pointer on this object.\n    *\n    * It is used as a way to detect if a javascript object that we received is an exported object by this library.\n    * @returns {number}\n    */\n    get getSophiaDatasetPtr() {\n        var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"datasetcore_get_sophia_dataset_ptr\"](this.ptr);\n        return ret;\n    }\n    /**\n    * Loads the content of a rdf graph formatted following the [TriG syntax](https://www.w3.org/TR/trig/)\n    * @param {string} content\n    */\n    load(content) {\n        var ptr0 = passStringToWasm0(content, _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbindgen_malloc\"], _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbindgen_realloc\"]);\n        var len0 = WASM_VECTOR_LEN;\n        _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"lightdataset_load\"](this.ptr, ptr0, len0);\n    }\n    /**\n    * Returns an array that contains every quads contained by this dataset\n    * @returns {Array<any>}\n    */\n    quads() {\n        var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"lightdataset_quads\"](this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * Returns every term contained by the dataset\n    * @returns {Array<any>}\n    */\n    getTerms() {\n        var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"lightdataset_getTerms\"](this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * Returns the number of quads contained by this dataset\n    * @returns {number}\n    */\n    get size() {\n        var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fastdataset_get_size\"](this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Returns a javascript style iterator on every quads on this dataset.\n    * @returns {RustExportIterator}\n    */\n    getIterator() {\n        var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"lightdataset_getIterator\"](this.ptr);\n        return RustExportIterator.__wrap(ret);\n    }\n    /**\n    * Adds the given quad to this dataset\n    * @param {any} quad\n    */\n    add(quad) {\n        try {\n            _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"lightdataset_add\"](this.ptr, addBorrowedObject(quad));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Deletes the passed quad from this dataset\n    * @param {any} quad\n    */\n    delete(quad) {\n        try {\n            _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"lightdataset_delete\"](this.ptr, addBorrowedObject(quad));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns `true` if this dataset has the passed quad\n    * @param {any} quad\n    * @returns {boolean}\n    */\n    has(quad) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"lightdataset_has\"](this.ptr, addBorrowedObject(quad));\n            return ret !== 0;\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Adds every quad contained in the passed dataset or sequence\n    * @param {any} quads_as_jsvalue\n    */\n    addAll(quads_as_jsvalue) {\n        try {\n            _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"lightdataset_addAll\"](this.ptr, addBorrowedObject(quads_as_jsvalue));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns true if imported_dataset is contained by this dataset\n    * @param {any} imported_dataset\n    * @returns {boolean}\n    */\n    contains(imported_dataset) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"lightdataset_contains\"](this.ptr, addBorrowedObject(imported_dataset));\n            return ret !== 0;\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Delete every quad that matches the given quad components\n    * @param {any} subject\n    * @param {any} predicate\n    * @param {any} object\n    * @param {any} graph\n    */\n    deleteMatches(subject, predicate, object, graph) {\n        try {\n            _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"lightdataset_deleteMatches\"](this.ptr, addBorrowedObject(subject), addBorrowedObject(predicate), addBorrowedObject(object), addBorrowedObject(graph));\n        } finally {\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns a new dataset which contains the elements of this dataset that are not included in the imported_dataset\n    * @param {any} imported_dataset\n    * @returns {LightDataset}\n    */\n    difference(imported_dataset) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"lightdataset_difference\"](this.ptr, addBorrowedObject(imported_dataset));\n            return LightDataset.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns true if the two datasets are equals\n    * @param {any} imported_dataset\n    * @returns {boolean}\n    */\n    equals(imported_dataset) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"lightdataset_equals\"](this.ptr, addBorrowedObject(imported_dataset));\n            return ret !== 0;\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns a dataset with the elements that are contained by both dataset\n    * @param {any} imported_dataset\n    * @returns {LightDataset}\n    */\n    intersection(imported_dataset) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"lightdataset_intersection\"](this.ptr, addBorrowedObject(imported_dataset));\n            return LightDataset.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns a dataset that contains all quads from the two graphs\n    * @param {any} imported_dataset\n    * @returns {LightDataset}\n    */\n    union(imported_dataset) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"lightdataset_union\"](this.ptr, addBorrowedObject(imported_dataset));\n            return LightDataset.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Produces an action for each quad of the dataset\n    * @param {Function} quad_run_iteratee\n    */\n    forEach(quad_run_iteratee) {\n        try {\n            _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"lightdataset_forEach\"](this.ptr, addBorrowedObject(quad_run_iteratee));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns true if the result of `filter_function` is true for at least\n    * one quad of the dataset\n    * @param {Function} filter_function\n    * @returns {boolean}\n    */\n    some(filter_function) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"lightdataset_some\"](this.ptr, addBorrowedObject(filter_function));\n            return ret !== 0;\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns true if the result of the passed function is true for every\n    * quad of the dataset\n    * @param {Function} filter_function\n    * @returns {boolean}\n    */\n    every(filter_function) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"lightdataset_every\"](this.ptr, addBorrowedObject(filter_function));\n            return ret !== 0;\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns a new dataset which contains every quads of this dataset that\n    * verifies the `filter_functio`\n    * @param {Function} filter_function\n    * @returns {LightDataset}\n    */\n    filter(filter_function) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"lightdataset_filter\"](this.ptr, addBorrowedObject(filter_function));\n            return LightDataset.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Builds a new dataset which contains quads that have been built by\n    * applying the map function to every quad of this dataset\n    * @param {Function} map_function\n    * @returns {LightDataset}\n    */\n    map(map_function) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"lightdataset_map\"](this.ptr, addBorrowedObject(map_function));\n            return LightDataset.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns an array that contains every quad contained by this dataset\n    * @returns {Array<any>}\n    */\n    toArray() {\n        var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"lightdataset_toArray\"](this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * Returns a string representation of the quads contained in the dataset\n    * @returns {string}\n    */\n    toString() {\n        try {\n            _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"lightdataset_toString\"](8, this.ptr);\n            var r0 = getInt32Memory0()[8 / 4 + 0];\n            var r1 = getInt32Memory0()[8 / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbindgen_free\"](r0, r1);\n        }\n    }\n    /**\n    * Reduces the whole dataset to a single element\n    *\n    * The behavior of this function matches the `Array.prototype.reduce`\n    * function from EcmaScript.\n    * @param {Function} reducer\n    * @param {any} initial_value\n    * @returns {any}\n    */\n    reduce(reducer, initial_value) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"lightdataset_reduce\"](this.ptr, addHeapObject(reducer), addBorrowedObject(initial_value));\n            return takeObject(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\n/**\n* A Sophia `FastDataset` adapter that can be exported to an object that is almost compliant to a\n* [RDF.JS dataset](https://rdf.js.org/dataset-spec/#dataset-interface)\n*/\nclass LightDatasetToA {\n\n    static __wrap(ptr) {\n        const obj = Object.create(LightDatasetToA.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    free() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbg_lightdatasettoa_free\"](ptr);\n    }\n    /**\n    * Returns a new dataset that contains every quad that matches the passed arguments.\n    * Returns a new dataset that contains every quad that matches the passed arguments.\n    * @param {any} subject\n    * @param {any} predicate\n    * @param {any} object\n    * @param {any} graph\n    * @returns {ArrayDataset}\n    */\n    match(subject, predicate, object, graph) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"lightdatasettoa_match\"](this.ptr, addBorrowedObject(subject), addBorrowedObject(predicate), addBorrowedObject(object), addBorrowedObject(graph));\n            return ArrayDataset.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Constructs an empty `FastDataset` that have a RDF.JS interface.\n    */\n    constructor() {\n        var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"lightdataset_new\"]();\n        return LightDatasetToA.__wrap(ret);\n    }\n    /**\n    * Returns a pointer on this object.\n    *\n    * It is used as a way to detect if a javascript object that we received is an exported object by this library.\n    * @returns {number}\n    */\n    get getSophiaDatasetPtr() {\n        var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"datasetcore_get_sophia_dataset_ptr\"](this.ptr);\n        return ret;\n    }\n    /**\n    * Loads the content of a rdf graph formatted following the [TriG syntax](https://www.w3.org/TR/trig/)\n    * @param {string} content\n    */\n    load(content) {\n        var ptr0 = passStringToWasm0(content, _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbindgen_malloc\"], _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbindgen_realloc\"]);\n        var len0 = WASM_VECTOR_LEN;\n        _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"lightdatasettoa_load\"](this.ptr, ptr0, len0);\n    }\n    /**\n    * Returns an array that contains every quads contained by this dataset\n    * @returns {Array<any>}\n    */\n    quads() {\n        var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"lightdatasettoa_quads\"](this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * Returns every term contained by the dataset\n    * @returns {Array<any>}\n    */\n    getTerms() {\n        var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"lightdatasettoa_getTerms\"](this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * Returns the number of quads contained by this dataset\n    * @returns {number}\n    */\n    get size() {\n        var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"fastdataset_get_size\"](this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Returns a javascript style iterator on every quads on this dataset.\n    * @returns {RustExportIterator}\n    */\n    getIterator() {\n        var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"lightdatasettoa_getIterator\"](this.ptr);\n        return RustExportIterator.__wrap(ret);\n    }\n    /**\n    * Adds the given quad to this dataset\n    * @param {any} quad\n    */\n    add(quad) {\n        try {\n            _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"lightdatasettoa_add\"](this.ptr, addBorrowedObject(quad));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Deletes the passed quad from this dataset\n    * @param {any} quad\n    */\n    delete(quad) {\n        try {\n            _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"lightdataset_delete\"](this.ptr, addBorrowedObject(quad));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns `true` if this dataset has the passed quad\n    * @param {any} quad\n    * @returns {boolean}\n    */\n    has(quad) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"lightdataset_has\"](this.ptr, addBorrowedObject(quad));\n            return ret !== 0;\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Adds every quad contained in the passed dataset or sequence\n    * @param {any} quads_as_jsvalue\n    */\n    addAll(quads_as_jsvalue) {\n        try {\n            _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"lightdatasettoa_addAll\"](this.ptr, addBorrowedObject(quads_as_jsvalue));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns true if imported_dataset is contained by this dataset\n    * @param {any} imported_dataset\n    * @returns {boolean}\n    */\n    contains(imported_dataset) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"lightdatasettoa_contains\"](this.ptr, addBorrowedObject(imported_dataset));\n            return ret !== 0;\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Delete every quad that matches the given quad components\n    * @param {any} subject\n    * @param {any} predicate\n    * @param {any} object\n    * @param {any} graph\n    */\n    deleteMatches(subject, predicate, object, graph) {\n        try {\n            _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"lightdataset_deleteMatches\"](this.ptr, addBorrowedObject(subject), addBorrowedObject(predicate), addBorrowedObject(object), addBorrowedObject(graph));\n        } finally {\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns a new dataset which contains the elements of this dataset that are not included in the imported_dataset\n    * @param {any} imported_dataset\n    * @returns {LightDatasetToA}\n    */\n    difference(imported_dataset) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"lightdatasettoa_difference\"](this.ptr, addBorrowedObject(imported_dataset));\n            return LightDatasetToA.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns true if the two datasets are equals\n    * @param {any} imported_dataset\n    * @returns {boolean}\n    */\n    equals(imported_dataset) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"lightdatasettoa_equals\"](this.ptr, addBorrowedObject(imported_dataset));\n            return ret !== 0;\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns a dataset with the elements that are contained by both dataset\n    * @param {any} imported_dataset\n    * @returns {LightDatasetToA}\n    */\n    intersection(imported_dataset) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"lightdatasettoa_intersection\"](this.ptr, addBorrowedObject(imported_dataset));\n            return LightDatasetToA.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns a dataset that contains all quads from the two graphs\n    * @param {any} imported_dataset\n    * @returns {LightDatasetToA}\n    */\n    union(imported_dataset) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"lightdatasettoa_union\"](this.ptr, addBorrowedObject(imported_dataset));\n            return LightDatasetToA.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Produces an action for each quad of the dataset\n    * @param {Function} quad_run_iteratee\n    */\n    forEach(quad_run_iteratee) {\n        try {\n            _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"lightdatasettoa_forEach\"](this.ptr, addBorrowedObject(quad_run_iteratee));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns true if the result of `filter_function` is true for at least\n    * one quad of the dataset\n    * @param {Function} filter_function\n    * @returns {boolean}\n    */\n    some(filter_function) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"lightdatasettoa_some\"](this.ptr, addBorrowedObject(filter_function));\n            return ret !== 0;\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns true if the result of the passed function is true for every\n    * quad of the dataset\n    * @param {Function} filter_function\n    * @returns {boolean}\n    */\n    every(filter_function) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"lightdatasettoa_every\"](this.ptr, addBorrowedObject(filter_function));\n            return ret !== 0;\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns a new dataset which contains every quads of this dataset that\n    * verifies the `filter_functio`\n    * @param {Function} filter_function\n    * @returns {LightDatasetToA}\n    */\n    filter(filter_function) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"lightdatasettoa_filter\"](this.ptr, addBorrowedObject(filter_function));\n            return LightDatasetToA.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Builds a new dataset which contains quads that have been built by\n    * applying the map function to every quad of this dataset\n    * @param {Function} map_function\n    * @returns {LightDatasetToA}\n    */\n    map(map_function) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"lightdatasettoa_map\"](this.ptr, addBorrowedObject(map_function));\n            return LightDatasetToA.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns an array that contains every quad contained by this dataset\n    * @returns {Array<any>}\n    */\n    toArray() {\n        var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"lightdatasettoa_toArray\"](this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * Returns a string representation of the quads contained in the dataset\n    * @returns {string}\n    */\n    toString() {\n        try {\n            _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"lightdatasettoa_toString\"](8, this.ptr);\n            var r0 = getInt32Memory0()[8 / 4 + 0];\n            var r1 = getInt32Memory0()[8 / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbindgen_free\"](r0, r1);\n        }\n    }\n    /**\n    * Reduces the whole dataset to a single element\n    *\n    * The behavior of this function matches the `Array.prototype.reduce`\n    * function from EcmaScript.\n    * @param {Function} reducer\n    * @param {any} initial_value\n    * @returns {any}\n    */\n    reduce(reducer, initial_value) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"lightdatasettoa_reduce\"](this.ptr, addHeapObject(reducer), addBorrowedObject(initial_value));\n            return takeObject(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\n/**\n* A SophiaExportQuad owns its data in the form of four RcTerms.\n*/\nclass Quad {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Quad.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    free() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbg_quad_free\"](ptr);\n    }\n    /**\n    * Returns the subject of the quad\n    * @returns {Term}\n    */\n    get subject() {\n        var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"quad_subject\"](this.ptr);\n        return Term.__wrap(ret);\n    }\n    /**\n    * Returns the predicate of the quad\n    * @returns {Term}\n    */\n    get predicate() {\n        var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"quad_predicate\"](this.ptr);\n        return Term.__wrap(ret);\n    }\n    /**\n    * Returns the object of the quad\n    * @returns {Term}\n    */\n    get object() {\n        var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"quad_object\"](this.ptr);\n        return Term.__wrap(ret);\n    }\n    /**\n    * Returns the graph of the quad\n    * @returns {Term}\n    */\n    get graph() {\n        var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"quad_graph\"](this.ptr);\n        return Term.__wrap(ret);\n    }\n    /**\n    * Returns a N-Quad representation of the quad\n    * @returns {string}\n    */\n    toString() {\n        try {\n            _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"quad_toString\"](8, this.ptr);\n            var r0 = getInt32Memory0()[8 / 4 + 0];\n            var r1 = getInt32Memory0()[8 / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbindgen_free\"](r0, r1);\n        }\n    }\n    /**\n    * Returns true if the passed quad is identical to this quad according to\n    * RDF.JS specification ie the subject, predicate, object and graph are\n    * the same.\n    * @param {any} other\n    * @returns {boolean}\n    */\n    equals(other) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"quad_equals\"](this.ptr, addBorrowedObject(other));\n            return ret !== 0;\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Modifies the subject of this quad\n    * @param {any} other\n    */\n    set subject(other) {\n        try {\n            _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"quad_set_subject\"](this.ptr, addBorrowedObject(other));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Modifies the predicate of this quad\n    * @param {any} other\n    */\n    set predicate(other) {\n        try {\n            _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"quad_set_predicate\"](this.ptr, addBorrowedObject(other));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Modifies the object of this quad\n    * @param {any} other\n    */\n    set object(other) {\n        try {\n            _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"quad_set_object\"](this.ptr, addBorrowedObject(other));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Modifies the graph of this quad\n    * @param {any} other\n    */\n    set graph(other) {\n        try {\n            _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"quad_set_graph\"](this.ptr, addBorrowedObject(other));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns a pointer to this quad.\n    *\n    * This is mainly used to be able to detect a Rust managed quad from an\n    * imported quad (as wasm_bindgen doesn't let us use polymorphism).\n    *\n    * Using this method can be very unsafe because it supposes only this\n    * object has a method called getRustPtr in the Javascript world.\n    * @returns {number}\n    */\n    get getRustPtr() {\n        var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"arraydataset_get_sophia_dataset_ptr\"](this.ptr);\n        return ret;\n    }\n}\n/**\n*/\nclass RandomValues {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RandomValues.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    free() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbg_randomvalues_free\"](ptr);\n    }\n    /**\n    * @param {number} array_length\n    */\n    constructor(array_length) {\n        var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"randomvalues_new\"](array_length);\n        return RandomValues.__wrap(ret);\n    }\n}\n/**\n* An exportable iterator on that keeps an array of every elements that needs\n* to be iterated on\n*/\nclass RustExportIterator {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RustExportIterator.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    free() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbg_rustexportiterator_free\"](ptr);\n    }\n    /**\n    * Returns an `RustExportIteratorNext` that contains to the next element.\n    * This corresponds to the next function in Javascript iterators.\n    * @returns {RustExportIteratorNext}\n    */\n    next() {\n        var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"rustexportiterator_next\"](this.ptr);\n        return RustExportIteratorNext.__wrap(ret);\n    }\n}\n/**\n* An object that contains an element returned by `RustExportIterator::next`\n*\n* It follows the Javascript specification, having a `done` attribute that tells if the iterator is empty and a\n* `value` attribute that contains the eventual value. They are modelized with an optional `JsValue`.\n*/\nclass RustExportIteratorNext {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RustExportIteratorNext.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    free() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbg_rustexportiteratornext_free\"](ptr);\n    }\n    /**\n    * Return true if the iterator is empty\n    * @returns {boolean}\n    */\n    get done() {\n        var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"rustexportiteratornext_done\"](this.ptr);\n        return ret !== 0;\n    }\n    /**\n    * Return the possessed `JsValue`\n    * @returns {any}\n    */\n    get value() {\n        var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"rustexportiteratornext_value\"](this.ptr);\n        return takeObject(ret);\n    }\n}\n/**\n* Exportation of rust terms using an adapter that owns the term\n*/\nclass Term {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Term.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    free() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbg_term_free\"](ptr);\n    }\n    /**\n    * Returns the term type of this term.\n    *\n    * The returned value can either be NamedNode, BlankNode, Literal,\n    * Variable or DefaultGraph.\n    * @returns {string}\n    */\n    get termType() {\n        try {\n            _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"term_term_type\"](8, this.ptr);\n            var r0 = getInt32Memory0()[8 / 4 + 0];\n            var r1 = getInt32Memory0()[8 / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbindgen_free\"](r0, r1);\n        }\n    }\n    /**\n    * Returns the value of this term\n    * @returns {string}\n    */\n    get value() {\n        try {\n            _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"term_value\"](8, this.ptr);\n            var r0 = getInt32Memory0()[8 / 4 + 0];\n            var r1 = getInt32Memory0()[8 / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbindgen_free\"](r0, r1);\n        }\n    }\n    /**\n    * Modifies the value of this term\n    * @param {string} new_value\n    */\n    set value(new_value) {\n        var ptr0 = passStringToWasm0(new_value, _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbindgen_malloc\"], _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbindgen_realloc\"]);\n        var len0 = WASM_VECTOR_LEN;\n        _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"term_set_value\"](this.ptr, ptr0, len0);\n    }\n    /**\n    * Returns the language of this term or an empty string if not applicable\n    * @returns {string}\n    */\n    get language() {\n        try {\n            _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"term_language\"](8, this.ptr);\n            var r0 = getInt32Memory0()[8 / 4 + 0];\n            var r1 = getInt32Memory0()[8 / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbindgen_free\"](r0, r1);\n        }\n    }\n    /**\n    * Modifies the language of this term if applicable\n    * @param {string} language\n    */\n    set language(language) {\n        var ptr0 = passStringToWasm0(language, _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbindgen_malloc\"], _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbindgen_realloc\"]);\n        var len0 = WASM_VECTOR_LEN;\n        _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"term_set_language\"](this.ptr, ptr0, len0);\n    }\n    /**\n    * Returns the datatype of this term if applicable\n    * @returns {Term | undefined}\n    */\n    get datatype() {\n        var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"term_datatype\"](this.ptr);\n        return ret === 0 ? undefined : Term.__wrap(ret);\n    }\n    /**\n    * Modifies the dataset of this literal if applicable\n    * @param {any} named_node\n    */\n    set datatype(named_node) {\n        try {\n            _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"term_set_datatype\"](this.ptr, addBorrowedObject(named_node));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns true if this term and the given term are equals according to\n    * RDF.JS specification.\n    *\n    * Two terms are identical if their termType, value and eventual language\n    * or datatype are the same.\n    * @param {any} other\n    * @returns {boolean}\n    */\n    equals(other) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"term_equals\"](this.ptr, addBorrowedObject(other));\n            return ret !== 0;\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns the n3 representation of this term\n    * @returns {string}\n    */\n    toString() {\n        try {\n            _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"term_toString\"](8, this.ptr);\n            var r0 = getInt32Memory0()[8 / 4 + 0];\n            var r1 = getInt32Memory0()[8 / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbindgen_free\"](r0, r1);\n        }\n    }\n}\n/**\n* A Sophia `FastDataset` adapter that can be exported to an object that is almost compliant to a\n* [RDF.JS dataset](https://rdf.js.org/dataset-spec/#dataset-interface)\n*/\nclass TreeDataset {\n\n    static __wrap(ptr) {\n        const obj = Object.create(TreeDataset.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    free() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbg_treedataset_free\"](ptr);\n    }\n    /**\n    * Returns a new dataset that contains every quad that matches the passed arguments.\n    * Returns a new dataset that contains every quad that matches the passed arguments.\n    * @param {any} subject\n    * @param {any} predicate\n    * @param {any} object\n    * @param {any} graph\n    * @returns {TreeDataset}\n    */\n    match(subject, predicate, object, graph) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"treedataset_match\"](this.ptr, addBorrowedObject(subject), addBorrowedObject(predicate), addBorrowedObject(object), addBorrowedObject(graph));\n            return TreeDataset.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Constructs an empty `FastDataset` that have a RDF.JS interface.\n    */\n    constructor() {\n        var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"datasetcore_new\"]();\n        return TreeDataset.__wrap(ret);\n    }\n    /**\n    * Returns a pointer on this object.\n    *\n    * It is used as a way to detect if a javascript object that we received is an exported object by this library.\n    * @returns {number}\n    */\n    get getSophiaDatasetPtr() {\n        var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"datasetcore_get_sophia_dataset_ptr\"](this.ptr);\n        return ret;\n    }\n    /**\n    * Loads the content of a rdf graph formatted following the [TriG syntax](https://www.w3.org/TR/trig/)\n    * @param {string} content\n    */\n    load(content) {\n        var ptr0 = passStringToWasm0(content, _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbindgen_malloc\"], _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbindgen_realloc\"]);\n        var len0 = WASM_VECTOR_LEN;\n        _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"treedataset_load\"](this.ptr, ptr0, len0);\n    }\n    /**\n    * Returns an array that contains every quads contained by this dataset\n    * @returns {Array<any>}\n    */\n    quads() {\n        var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"treedataset_quads\"](this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * Returns every term contained by the dataset\n    * @returns {Array<any>}\n    */\n    getTerms() {\n        var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"treedataset_getTerms\"](this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * Returns the number of quads contained by this dataset\n    * @returns {number}\n    */\n    get size() {\n        var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"treedataset_get_size\"](this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Returns a javascript style iterator on every quads on this dataset.\n    * @returns {RustExportIterator}\n    */\n    getIterator() {\n        var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"treedataset_getIterator\"](this.ptr);\n        return RustExportIterator.__wrap(ret);\n    }\n    /**\n    * Adds the given quad to this dataset\n    * @param {any} quad\n    */\n    add(quad) {\n        try {\n            _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"treedataset_add\"](this.ptr, addBorrowedObject(quad));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Deletes the passed quad from this dataset\n    * @param {any} quad\n    */\n    delete(quad) {\n        try {\n            _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"datasetcore_delete\"](this.ptr, addBorrowedObject(quad));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns `true` if this dataset has the passed quad\n    * @param {any} quad\n    * @returns {boolean}\n    */\n    has(quad) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"treedataset_has\"](this.ptr, addBorrowedObject(quad));\n            return ret !== 0;\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Adds every quad contained in the passed dataset or sequence\n    * @param {any} quads_as_jsvalue\n    */\n    addAll(quads_as_jsvalue) {\n        try {\n            _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"treedataset_addAll\"](this.ptr, addBorrowedObject(quads_as_jsvalue));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns true if imported_dataset is contained by this dataset\n    * @param {any} imported_dataset\n    * @returns {boolean}\n    */\n    contains(imported_dataset) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"treedataset_contains\"](this.ptr, addBorrowedObject(imported_dataset));\n            return ret !== 0;\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Delete every quad that matches the given quad components\n    * @param {any} subject\n    * @param {any} predicate\n    * @param {any} object\n    * @param {any} graph\n    */\n    deleteMatches(subject, predicate, object, graph) {\n        try {\n            _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"datasetcore_deleteMatches\"](this.ptr, addBorrowedObject(subject), addBorrowedObject(predicate), addBorrowedObject(object), addBorrowedObject(graph));\n        } finally {\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns a new dataset which contains the elements of this dataset that are not included in the imported_dataset\n    * @param {any} imported_dataset\n    * @returns {TreeDataset}\n    */\n    difference(imported_dataset) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"treedataset_difference\"](this.ptr, addBorrowedObject(imported_dataset));\n            return TreeDataset.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns true if the two datasets are equals\n    * @param {any} imported_dataset\n    * @returns {boolean}\n    */\n    equals(imported_dataset) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"treedataset_equals\"](this.ptr, addBorrowedObject(imported_dataset));\n            return ret !== 0;\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns a dataset with the elements that are contained by both dataset\n    * @param {any} imported_dataset\n    * @returns {TreeDataset}\n    */\n    intersection(imported_dataset) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"treedataset_intersection\"](this.ptr, addBorrowedObject(imported_dataset));\n            return TreeDataset.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns a dataset that contains all quads from the two graphs\n    * @param {any} imported_dataset\n    * @returns {TreeDataset}\n    */\n    union(imported_dataset) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"treedataset_union\"](this.ptr, addBorrowedObject(imported_dataset));\n            return TreeDataset.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Produces an action for each quad of the dataset\n    * @param {Function} quad_run_iteratee\n    */\n    forEach(quad_run_iteratee) {\n        try {\n            _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"treedataset_forEach\"](this.ptr, addBorrowedObject(quad_run_iteratee));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns true if the result of `filter_function` is true for at least\n    * one quad of the dataset\n    * @param {Function} filter_function\n    * @returns {boolean}\n    */\n    some(filter_function) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"treedataset_some\"](this.ptr, addBorrowedObject(filter_function));\n            return ret !== 0;\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns true if the result of the passed function is true for every\n    * quad of the dataset\n    * @param {Function} filter_function\n    * @returns {boolean}\n    */\n    every(filter_function) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"treedataset_every\"](this.ptr, addBorrowedObject(filter_function));\n            return ret !== 0;\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns a new dataset which contains every quads of this dataset that\n    * verifies the `filter_functio`\n    * @param {Function} filter_function\n    * @returns {TreeDataset}\n    */\n    filter(filter_function) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"treedataset_filter\"](this.ptr, addBorrowedObject(filter_function));\n            return TreeDataset.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Builds a new dataset which contains quads that have been built by\n    * applying the map function to every quad of this dataset\n    * @param {Function} map_function\n    * @returns {TreeDataset}\n    */\n    map(map_function) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"treedataset_map\"](this.ptr, addBorrowedObject(map_function));\n            return TreeDataset.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns an array that contains every quad contained by this dataset\n    * @returns {Array<any>}\n    */\n    toArray() {\n        var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"treedataset_toArray\"](this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * Returns a string representation of the quads contained in the dataset\n    * @returns {string}\n    */\n    toString() {\n        try {\n            _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"treedataset_toString\"](8, this.ptr);\n            var r0 = getInt32Memory0()[8 / 4 + 0];\n            var r1 = getInt32Memory0()[8 / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbindgen_free\"](r0, r1);\n        }\n    }\n    /**\n    * Reduces the whole dataset to a single element\n    *\n    * The behavior of this function matches the `Array.prototype.reduce`\n    * function from EcmaScript.\n    * @param {Function} reducer\n    * @param {any} initial_value\n    * @returns {any}\n    */\n    reduce(reducer, initial_value) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"treedataset_reduce\"](this.ptr, addHeapObject(reducer), addBorrowedObject(initial_value));\n            return takeObject(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\n/**\n* A Sophia `FastDataset` adapter that can be exported to an object that is almost compliant to a\n* [RDF.JS dataset](https://rdf.js.org/dataset-spec/#dataset-interface)\n*/\nclass TreeDatasetToA {\n\n    static __wrap(ptr) {\n        const obj = Object.create(TreeDatasetToA.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    free() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbg_treedatasettoa_free\"](ptr);\n    }\n    /**\n    * Returns a new dataset that contains every quad that matches the passed arguments.\n    * Returns a new dataset that contains every quad that matches the passed arguments.\n    * @param {any} subject\n    * @param {any} predicate\n    * @param {any} object\n    * @param {any} graph\n    * @returns {ArrayDataset}\n    */\n    match(subject, predicate, object, graph) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"treedatasettoa_match\"](this.ptr, addBorrowedObject(subject), addBorrowedObject(predicate), addBorrowedObject(object), addBorrowedObject(graph));\n            return ArrayDataset.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Constructs an empty `FastDataset` that have a RDF.JS interface.\n    */\n    constructor() {\n        var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"datasetcore_new\"]();\n        return TreeDatasetToA.__wrap(ret);\n    }\n    /**\n    * Returns a pointer on this object.\n    *\n    * It is used as a way to detect if a javascript object that we received is an exported object by this library.\n    * @returns {number}\n    */\n    get getSophiaDatasetPtr() {\n        var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"datasetcore_get_sophia_dataset_ptr\"](this.ptr);\n        return ret;\n    }\n    /**\n    * Loads the content of a rdf graph formatted following the [TriG syntax](https://www.w3.org/TR/trig/)\n    * @param {string} content\n    */\n    load(content) {\n        var ptr0 = passStringToWasm0(content, _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbindgen_malloc\"], _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbindgen_realloc\"]);\n        var len0 = WASM_VECTOR_LEN;\n        _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"treedataset_load\"](this.ptr, ptr0, len0);\n    }\n    /**\n    * Returns an array that contains every quads contained by this dataset\n    * @returns {Array<any>}\n    */\n    quads() {\n        var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"treedataset_quads\"](this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * Returns every term contained by the dataset\n    * @returns {Array<any>}\n    */\n    getTerms() {\n        var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"treedataset_getTerms\"](this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * Returns the number of quads contained by this dataset\n    * @returns {number}\n    */\n    get size() {\n        var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"treedataset_get_size\"](this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Returns a javascript style iterator on every quads on this dataset.\n    * @returns {RustExportIterator}\n    */\n    getIterator() {\n        var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"treedataset_getIterator\"](this.ptr);\n        return RustExportIterator.__wrap(ret);\n    }\n    /**\n    * Adds the given quad to this dataset\n    * @param {any} quad\n    */\n    add(quad) {\n        try {\n            _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"treedataset_add\"](this.ptr, addBorrowedObject(quad));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Deletes the passed quad from this dataset\n    * @param {any} quad\n    */\n    delete(quad) {\n        try {\n            _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"datasetcore_delete\"](this.ptr, addBorrowedObject(quad));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns `true` if this dataset has the passed quad\n    * @param {any} quad\n    * @returns {boolean}\n    */\n    has(quad) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"treedataset_has\"](this.ptr, addBorrowedObject(quad));\n            return ret !== 0;\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Adds every quad contained in the passed dataset or sequence\n    * @param {any} quads_as_jsvalue\n    */\n    addAll(quads_as_jsvalue) {\n        try {\n            _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"treedatasettoa_addAll\"](this.ptr, addBorrowedObject(quads_as_jsvalue));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns true if imported_dataset is contained by this dataset\n    * @param {any} imported_dataset\n    * @returns {boolean}\n    */\n    contains(imported_dataset) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"treedatasettoa_contains\"](this.ptr, addBorrowedObject(imported_dataset));\n            return ret !== 0;\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Delete every quad that matches the given quad components\n    * @param {any} subject\n    * @param {any} predicate\n    * @param {any} object\n    * @param {any} graph\n    */\n    deleteMatches(subject, predicate, object, graph) {\n        try {\n            _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"datasetcore_deleteMatches\"](this.ptr, addBorrowedObject(subject), addBorrowedObject(predicate), addBorrowedObject(object), addBorrowedObject(graph));\n        } finally {\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns a new dataset which contains the elements of this dataset that are not included in the imported_dataset\n    * @param {any} imported_dataset\n    * @returns {TreeDatasetToA}\n    */\n    difference(imported_dataset) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"treedatasettoa_difference\"](this.ptr, addBorrowedObject(imported_dataset));\n            return TreeDatasetToA.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns true if the two datasets are equals\n    * @param {any} imported_dataset\n    * @returns {boolean}\n    */\n    equals(imported_dataset) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"treedatasettoa_equals\"](this.ptr, addBorrowedObject(imported_dataset));\n            return ret !== 0;\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns a dataset with the elements that are contained by both dataset\n    * @param {any} imported_dataset\n    * @returns {TreeDatasetToA}\n    */\n    intersection(imported_dataset) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"treedatasettoa_intersection\"](this.ptr, addBorrowedObject(imported_dataset));\n            return TreeDatasetToA.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns a dataset that contains all quads from the two graphs\n    * @param {any} imported_dataset\n    * @returns {TreeDatasetToA}\n    */\n    union(imported_dataset) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"treedatasettoa_union\"](this.ptr, addBorrowedObject(imported_dataset));\n            return TreeDatasetToA.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Produces an action for each quad of the dataset\n    * @param {Function} quad_run_iteratee\n    */\n    forEach(quad_run_iteratee) {\n        try {\n            _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"treedataset_forEach\"](this.ptr, addBorrowedObject(quad_run_iteratee));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns true if the result of `filter_function` is true for at least\n    * one quad of the dataset\n    * @param {Function} filter_function\n    * @returns {boolean}\n    */\n    some(filter_function) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"treedataset_some\"](this.ptr, addBorrowedObject(filter_function));\n            return ret !== 0;\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns true if the result of the passed function is true for every\n    * quad of the dataset\n    * @param {Function} filter_function\n    * @returns {boolean}\n    */\n    every(filter_function) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"treedataset_every\"](this.ptr, addBorrowedObject(filter_function));\n            return ret !== 0;\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns a new dataset which contains every quads of this dataset that\n    * verifies the `filter_functio`\n    * @param {Function} filter_function\n    * @returns {TreeDatasetToA}\n    */\n    filter(filter_function) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"treedataset_filter\"](this.ptr, addBorrowedObject(filter_function));\n            return TreeDatasetToA.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Builds a new dataset which contains quads that have been built by\n    * applying the map function to every quad of this dataset\n    * @param {Function} map_function\n    * @returns {TreeDatasetToA}\n    */\n    map(map_function) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"treedatasettoa_map\"](this.ptr, addBorrowedObject(map_function));\n            return TreeDatasetToA.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Returns an array that contains every quad contained by this dataset\n    * @returns {Array<any>}\n    */\n    toArray() {\n        var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"treedataset_toArray\"](this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * Returns a string representation of the quads contained in the dataset\n    * @returns {string}\n    */\n    toString() {\n        try {\n            _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"treedataset_toString\"](8, this.ptr);\n            var r0 = getInt32Memory0()[8 / 4 + 0];\n            var r1 = getInt32Memory0()[8 / 4 + 1];\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbindgen_free\"](r0, r1);\n        }\n    }\n    /**\n    * Reduces the whole dataset to a single element\n    *\n    * The behavior of this function matches the `Array.prototype.reduce`\n    * function from EcmaScript.\n    * @param {Function} reducer\n    * @param {any} initial_value\n    * @returns {any}\n    */\n    reduce(reducer, initial_value) {\n        try {\n            var ret = _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"treedataset_reduce\"](this.ptr, addHeapObject(reducer), addBorrowedObject(initial_value));\n            return takeObject(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\n\nconst __wbindgen_object_drop_ref = function(arg0) {\n    takeObject(arg0);\n};\n\nconst __wbg_termtype_a4a786613f0caa0c = function(arg0, arg1) {\n    var ret = getObject(arg1).termType;\n    var ptr0 = passStringToWasm0(ret, _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbindgen_malloc\"], _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbindgen_realloc\"]);\n    var len0 = WASM_VECTOR_LEN;\n    getInt32Memory0()[arg0 / 4 + 1] = len0;\n    getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n};\n\nconst __wbg_value_e1025b733d3dba1e = function(arg0, arg1) {\n    var ret = getObject(arg1).value;\n    var ptr0 = passStringToWasm0(ret, _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbindgen_malloc\"], _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbindgen_realloc\"]);\n    var len0 = WASM_VECTOR_LEN;\n    getInt32Memory0()[arg0 / 4 + 1] = len0;\n    getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n};\n\nconst __wbg_language_879613ccdf6a457b = function(arg0, arg1) {\n    var ret = getObject(arg1).language;\n    var ptr0 = passStringToWasm0(ret, _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbindgen_malloc\"], _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbindgen_realloc\"]);\n    var len0 = WASM_VECTOR_LEN;\n    getInt32Memory0()[arg0 / 4 + 1] = len0;\n    getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n};\n\nconst __wbg_datatype_2ba7293e0b888706 = function(arg0) {\n    var ret = getObject(arg0).datatype;\n    return addHeapObject(ret);\n};\n\nconst __wbg_log_83c9c7e7afe8209f = function(arg0, arg1) {\n    console.log(getStringFromWasm0(arg0, arg1));\n};\n\nconst __wbindgen_is_null = function(arg0) {\n    var ret = getObject(arg0) === null;\n    return ret;\n};\n\nconst __wbindgen_is_undefined = function(arg0) {\n    var ret = getObject(arg0) === undefined;\n    return ret;\n};\n\nconst __wbg_term_new = function(arg0) {\n    var ret = Term.__wrap(arg0);\n    return addHeapObject(ret);\n};\n\nconst __wbg_subject_048e66f68a4b1268 = function(arg0) {\n    var ret = getObject(arg0).subject;\n    return addHeapObject(ret);\n};\n\nconst __wbg_object_54cb599f4cc13178 = function(arg0) {\n    var ret = getObject(arg0).object;\n    return addHeapObject(ret);\n};\n\nconst __wbg_predicate_348a7e9650639bdd = function(arg0) {\n    var ret = getObject(arg0).predicate;\n    return addHeapObject(ret);\n};\n\nconst __wbg_graph_4185eaeb9b616609 = function(arg0) {\n    var ret = getObject(arg0).graph;\n    return addHeapObject(ret);\n};\n\nconst __wbg_quadsgetrustptr_e356b53a099c2f60 = function(arg0) {\n    var ret = getObject(arg0).getRustPtr;\n    return ret;\n};\n\nconst __wbg_quad_new = function(arg0) {\n    var ret = Quad.__wrap(arg0);\n    return addHeapObject(ret);\n};\n\nconst __wbindgen_object_clone_ref = function(arg0) {\n    var ret = getObject(arg0);\n    return addHeapObject(ret);\n};\n\nconst __wbg_getsophiadatasetptr_75cef6ca00ba6515 = function(arg0) {\n    var ret = getObject(arg0).getSophiaDatasetPtr;\n    return ret;\n};\n\nconst __wbindgen_is_falsy = function(arg0) {\n    var ret = !getObject(arg0);\n    return ret;\n};\n\nconst __wbg_getsophiadatasetptr_a4d4b90cb7b6cef6 = function(arg0) {\n    var ret = getObject(arg0).getSophiaDatasetPtr;\n    return ret;\n};\n\nconst __wbg_getsophiadatasetptr_d6660d2c5b1b0122 = function(arg0) {\n    var ret = getObject(arg0).getSophiaDatasetPtr;\n    return ret;\n};\n\nconst __wbg_getsophiadatasetptr_8af02521c77b8172 = function(arg0) {\n    var ret = getObject(arg0).getSophiaDatasetPtr;\n    return ret;\n};\n\nconst __wbg_getsophiadatasetptr_fd13de8002947660 = function(arg0) {\n    var ret = getObject(arg0).getSophiaDatasetPtr;\n    return ret;\n};\n\nconst __wbg_getsophiadatasetptr_cd4122b7c7bee63a = function(arg0) {\n    var ret = getObject(arg0).getSophiaDatasetPtr;\n    return ret;\n};\n\nconst __wbg_getsophiadatasetptr_4d9e9165c5b31627 = function(arg0) {\n    var ret = getObject(arg0).getSophiaDatasetPtr;\n    return ret;\n};\n\nconst __wbg_getsophiadatasetptr_85e6682f053e1121 = function(arg0) {\n    var ret = getObject(arg0).getSophiaDatasetPtr;\n    return ret;\n};\n\nconst __wbg_getsophiadatasetptr_16ee8ea079b18b62 = function(arg0) {\n    var ret = getObject(arg0).getSophiaDatasetPtr;\n    return ret;\n};\n\nconst __wbg_getsophiadatasetptr_bdb7942fc9f67c06 = function(arg0) {\n    var ret = getObject(arg0).getSophiaDatasetPtr;\n    return ret;\n};\n\nconst __wbg_self_1b7a39e3a92c949c = handleError(function() {\n    var ret = self.self;\n    return addHeapObject(ret);\n});\n\nconst __wbg_require_604837428532a733 = function(arg0, arg1) {\n    var ret = __webpack_require__(\"../Portable-Reasoning-in-Web-Assembly/sophia-wasm/pkg sync recursive\")(getStringFromWasm0(arg0, arg1));\n    return addHeapObject(ret);\n};\n\nconst __wbg_crypto_968f1772287e2df0 = function(arg0) {\n    var ret = getObject(arg0).crypto;\n    return addHeapObject(ret);\n};\n\nconst __wbg_getRandomValues_a3d34b4fee3c2869 = function(arg0) {\n    var ret = getObject(arg0).getRandomValues;\n    return addHeapObject(ret);\n};\n\nconst __wbg_getRandomValues_f5e14ab7ac8e995d = function(arg0, arg1, arg2) {\n    getObject(arg0).getRandomValues(getArrayU8FromWasm0(arg1, arg2));\n};\n\nconst __wbg_randomFillSync_d5bd2d655fdf256a = function(arg0, arg1, arg2) {\n    getObject(arg0).randomFillSync(getArrayU8FromWasm0(arg1, arg2));\n};\n\nconst __wbg_get_5fd9dd78e47d6ed2 = function(arg0, arg1) {\n    var ret = getObject(arg0)[arg1 >>> 0];\n    return addHeapObject(ret);\n};\n\nconst __wbg_length_0f0e68fde7e14c19 = function(arg0) {\n    var ret = getObject(arg0).length;\n    return ret;\n};\n\nconst __wbindgen_is_function = function(arg0) {\n    var ret = typeof(getObject(arg0)) === 'function';\n    return ret;\n};\n\nconst __wbindgen_is_object = function(arg0) {\n    const val = getObject(arg0);\n    var ret = typeof(val) === 'object' && val !== null;\n    return ret;\n};\n\nconst __wbg_next_3d6c9b2822b18fae = function(arg0) {\n    var ret = getObject(arg0).next;\n    return addHeapObject(ret);\n};\n\nconst __wbg_next_d2c829783697bd8e = handleError(function(arg0) {\n    var ret = getObject(arg0).next();\n    return addHeapObject(ret);\n});\n\nconst __wbg_done_a16709ea72553788 = function(arg0) {\n    var ret = getObject(arg0).done;\n    return ret;\n};\n\nconst __wbg_value_3093fb48085878da = function(arg0) {\n    var ret = getObject(arg0).value;\n    return addHeapObject(ret);\n};\n\nconst __wbg_iterator_f89e8caf932523b1 = function() {\n    var ret = Symbol.iterator;\n    return addHeapObject(ret);\n};\n\nconst __wbg_get_f2faf882de3801f1 = handleError(function(arg0, arg1) {\n    var ret = Reflect.get(getObject(arg0), getObject(arg1));\n    return addHeapObject(ret);\n});\n\nconst __wbg_call_1f85aaa5836dfb23 = handleError(function(arg0, arg1) {\n    var ret = getObject(arg0).call(getObject(arg1));\n    return addHeapObject(ret);\n});\n\nconst __wbg_new_0d50725e1ae68303 = function() {\n    var ret = new Array();\n    return addHeapObject(ret);\n};\n\nconst __wbg_pop_b02b7e73b5ac41c0 = function(arg0) {\n    var ret = getObject(arg0).pop();\n    return addHeapObject(ret);\n};\n\nconst __wbg_push_46274b393147c746 = function(arg0, arg1) {\n    var ret = getObject(arg0).push(getObject(arg1));\n    return ret;\n};\n\nconst __wbg_reverse_20f3cefd76d7f0da = function(arg0) {\n    var ret = getObject(arg0).reverse();\n    return addHeapObject(ret);\n};\n\nconst __wbg_call_0246f1c8ff252fb6 = handleError(function(arg0, arg1, arg2) {\n    var ret = getObject(arg0).call(getObject(arg1), getObject(arg2));\n    return addHeapObject(ret);\n});\n\nconst __wbg_call_740b86f47a550a76 = handleError(function(arg0, arg1, arg2, arg3) {\n    var ret = getObject(arg0).call(getObject(arg1), getObject(arg2), getObject(arg3));\n    return addHeapObject(ret);\n});\n\nconst __wbindgen_string_get = function(arg0, arg1) {\n    const obj = getObject(arg1);\n    var ret = typeof(obj) === 'string' ? obj : undefined;\n    var ptr0 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbindgen_malloc\"], _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbindgen_realloc\"]);\n    var len0 = WASM_VECTOR_LEN;\n    getInt32Memory0()[arg0 / 4 + 1] = len0;\n    getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n};\n\nconst __wbindgen_debug_string = function(arg0, arg1) {\n    var ret = debugString(getObject(arg1));\n    var ptr0 = passStringToWasm0(ret, _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbindgen_malloc\"], _sophia_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbindgen_realloc\"]);\n    var len0 = WASM_VECTOR_LEN;\n    getInt32Memory0()[arg0 / 4 + 1] = len0;\n    getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n};\n\nconst __wbindgen_throw = function(arg0, arg1) {\n    throw new Error(getStringFromWasm0(arg0, arg1));\n};\n\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../navbench/node_modules/webpack/buildin/harmony-module.js */ \"./node_modules/webpack/buildin/harmony-module.js\")(module)))\n\n//# sourceURL=webpack:///../Portable-Reasoning-in-Web-Assembly/sophia-wasm/pkg/sophia_wasm_bg.js?");

/***/ }),

/***/ "../Portable-Reasoning-in-Web-Assembly/sophia-wasm/pkg/sophia_wasm_bg.wasm":
/*!*********************************************************************************!*\
  !*** ../Portable-Reasoning-in-Web-Assembly/sophia-wasm/pkg/sophia_wasm_bg.wasm ***!
  \*********************************************************************************/
/*! exports provided: memory, __wbg_term_free, term_term_type, term_value, term_set_value, term_language, term_set_language, term_datatype, term_set_datatype, term_equals, term_toString, __wbg_quad_free, quad_subject, quad_predicate, quad_object, quad_graph, quad_toString, quad_equals, quad_set_subject, quad_set_predicate, quad_set_object, quad_set_graph, datafactory_namedNode, datafactory_blankNode, datafactory_literal, datafactory_literalFromString, datafactory_literalFromNamedNode, datafactory_variable, datafactory_defaultGraph, datafactory_quad, datafactory_triple, datafactory_fromTerm, datafactory_fromQuad, datafactory_dataset, __wbg_rustexportiterator_free, rustexportiterator_next, __wbg_rustexportiteratornext_free, rustexportiteratornext_done, rustexportiteratornext_value, __wbg_datasetcore_free, datasetcore_match, datasetcore_new, datasetcore_get_sophia_dataset_ptr, datasetcore_load, datasetcore_quads, datasetcore_getTerms, datasetcore_get_size, datasetcore_getIterator, datasetcore_add, datasetcore_delete, datasetcore_has, datasetcore_addAll, datasetcore_contains, datasetcore_deleteMatches, datasetcore_difference, datasetcore_equals, datasetcore_intersection, datasetcore_union, datasetcore_forEach, datasetcore_some, datasetcore_every, datasetcore_filter, datasetcore_map, datasetcore_toArray, datasetcore_toString, datasetcore_reduce, treedataset_match, treedataset_load, treedataset_quads, treedataset_getTerms, treedataset_get_size, treedataset_getIterator, treedataset_add, treedataset_has, treedataset_addAll, treedataset_contains, treedataset_difference, treedataset_equals, treedataset_intersection, treedataset_union, treedataset_forEach, treedataset_some, treedataset_every, treedataset_filter, treedataset_map, treedataset_toArray, treedataset_toString, treedataset_reduce, __wbg_fastdataset_free, fastdataset_match, fastdataset_new, fastdataset_load, fastdataset_quads, fastdataset_getTerms, fastdataset_get_size, fastdataset_getIterator, fastdataset_add, fastdataset_delete, fastdataset_has, fastdataset_addAll, fastdataset_contains, fastdataset_deleteMatches, fastdataset_difference, fastdataset_equals, fastdataset_intersection, fastdataset_union, fastdataset_forEach, fastdataset_some, fastdataset_every, fastdataset_filter, fastdataset_map, fastdataset_toArray, fastdataset_toString, fastdataset_reduce, __wbg_lightdataset_free, lightdataset_match, lightdataset_new, lightdataset_load, lightdataset_quads, lightdataset_getTerms, lightdataset_getIterator, lightdataset_add, lightdataset_delete, lightdataset_has, lightdataset_addAll, lightdataset_contains, lightdataset_deleteMatches, lightdataset_difference, lightdataset_equals, lightdataset_intersection, lightdataset_union, lightdataset_forEach, lightdataset_some, lightdataset_every, lightdataset_filter, lightdataset_map, lightdataset_toArray, lightdataset_toString, lightdataset_reduce, __wbg_fulldataset_free, fulldataset_match, fulldataset_new, fulldataset_load, fulldataset_quads, fulldataset_getTerms, fulldataset_get_size, fulldataset_getIterator, fulldataset_add, fulldataset_delete, fulldataset_has, fulldataset_addAll, fulldataset_contains, fulldataset_deleteMatches, fulldataset_difference, fulldataset_equals, fulldataset_intersection, fulldataset_union, fulldataset_forEach, fulldataset_some, fulldataset_every, fulldataset_filter, fulldataset_map, fulldataset_toArray, fulldataset_toString, fulldataset_reduce, __wbg_arraydataset_free, arraydataset_match, arraydataset_new, arraydataset_get_sophia_dataset_ptr, arraydataset_load, arraydataset_quads, arraydataset_getTerms, arraydataset_get_size, arraydataset_getIterator, arraydataset_add, arraydataset_delete, arraydataset_has, arraydataset_addAll, arraydataset_contains, arraydataset_deleteMatches, arraydataset_difference, arraydataset_equals, arraydataset_intersection, arraydataset_union, arraydataset_forEach, arraydataset_some, arraydataset_every, arraydataset_filter, arraydataset_map, arraydataset_toArray, arraydataset_toString, arraydataset_reduce, treedatasettoa_match, treedatasettoa_addAll, treedatasettoa_contains, treedatasettoa_difference, treedatasettoa_equals, treedatasettoa_intersection, treedatasettoa_union, treedatasettoa_map, fastdatasettoa_match, fastdatasettoa_load, fastdatasettoa_quads, fastdatasettoa_getTerms, fastdatasettoa_getIterator, fastdatasettoa_add, fastdatasettoa_addAll, fastdatasettoa_contains, fastdatasettoa_difference, fastdatasettoa_equals, fastdatasettoa_intersection, fastdatasettoa_union, fastdatasettoa_forEach, fastdatasettoa_some, fastdatasettoa_every, fastdatasettoa_filter, fastdatasettoa_map, fastdatasettoa_toArray, fastdatasettoa_toString, fastdatasettoa_reduce, lightdatasettoa_match, lightdatasettoa_load, lightdatasettoa_quads, lightdatasettoa_getTerms, lightdatasettoa_getIterator, lightdatasettoa_add, lightdatasettoa_addAll, lightdatasettoa_contains, lightdatasettoa_difference, lightdatasettoa_equals, lightdatasettoa_intersection, lightdatasettoa_union, lightdatasettoa_forEach, lightdatasettoa_some, lightdatasettoa_every, lightdatasettoa_filter, lightdatasettoa_map, lightdatasettoa_toArray, lightdatasettoa_toString, lightdatasettoa_reduce, fulldatasettoa_match, fulldatasettoa_load, fulldatasettoa_quads, fulldatasettoa_getTerms, fulldatasettoa_get_size, fulldatasettoa_getIterator, fulldatasettoa_add, fulldatasettoa_has, fulldatasettoa_addAll, fulldatasettoa_contains, fulldatasettoa_difference, fulldatasettoa_equals, fulldatasettoa_intersection, fulldatasettoa_union, fulldatasettoa_forEach, fulldatasettoa_some, fulldatasettoa_every, fulldatasettoa_filter, fulldatasettoa_map, fulldatasettoa_toArray, fulldatasettoa_toString, fulldatasettoa_reduce, __wbg_intvector_free, __wbg_inttree_free, sumvectorfullrust, intvector_new, intvector_using, intvector_fill_with_v, intvector_copy, intvector_sum_inf_to_v, intvector_sum_inf_to_t, inttree_new, inttree_using, inttree_copy, inttree_sum_inf_to_v, inttree_sum_inf_to_t, inttree_fill_with_v, randomvalues_new, __wbg_datafactory_free, __wbg_randomvalues_free, treedataset_delete, treedatasettoa_delete, fastdatasettoa_delete, fulldatasettoa_delete, lightdatasettoa_new, datafactory_new, treedataset_get_sophia_dataset_ptr, fastdataset_get_sophia_dataset_ptr, lightdataset_get_sophia_dataset_ptr, fulldataset_get_sophia_dataset_ptr, quad_quads_get_rust_ptr, treedatasettoa_get_sophia_dataset_ptr, fastdatasettoa_get_sophia_dataset_ptr, lightdatasettoa_get_sophia_dataset_ptr, fulldatasettoa_get_sophia_dataset_ptr, fastdatasettoa_has, __wbg_fastdatasettoa_free, __wbg_fulldatasettoa_free, lightdatasettoa_delete, treedataset_new, treedatasettoa_new, fastdatasettoa_new, fulldatasettoa_new, treedatasettoa_filter, __wbg_treedataset_free, __wbg_treedatasettoa_free, treedataset_deleteMatches, treedatasettoa_deleteMatches, fastdatasettoa_deleteMatches, lightdatasettoa_deleteMatches, fulldatasettoa_deleteMatches, treedatasettoa_add, treedatasettoa_reduce, lightdatasettoa_has, lightdataset_get_size, fastdatasettoa_get_size, lightdatasettoa_get_size, __wbg_lightdatasettoa_free, treedatasettoa_load, treedatasettoa_getTerms, treedatasettoa_has, treedatasettoa_some, treedatasettoa_every, treedatasettoa_forEach, treedatasettoa_toArray, treedatasettoa_getIterator, treedatasettoa_quads, treedatasettoa_get_size, treedatasettoa_toString, __wbindgen_malloc, __wbindgen_realloc, __wbindgen_free, __wbindgen_exn_store */
/***/ (function(module, exports, __webpack_require__) {

eval("\"use strict\";\n// Instantiate WebAssembly module\nvar wasmExports = __webpack_require__.w[module.i];\n__webpack_require__.r(exports);\n// export exports from WebAssembly module\nfor(var name in wasmExports) if(name != \"__webpack_init__\") exports[name] = wasmExports[name];\n// exec imports from WebAssembly module (for esm order)\n/* harmony import */ var m0 = __webpack_require__(/*! ./sophia_wasm_bg.js */ \"../Portable-Reasoning-in-Web-Assembly/sophia-wasm/pkg/sophia_wasm_bg.js\");\n\n\n// exec wasm module\nwasmExports[\"__webpack_init__\"]()\n\n//# sourceURL=webpack:///../Portable-Reasoning-in-Web-Assembly/sophia-wasm/pkg/sophia_wasm_bg.wasm?");

/***/ }),

/***/ "../WasmTreeDataset/wasm-tree-backend/pkg/wasm_tree_backend.js":
/*!*********************************************************************!*\
  !*** ../WasmTreeDataset/wasm-tree-backend/pkg/wasm_tree_backend.js ***!
  \*********************************************************************/
/*! exports provided: TreedDataset, __wbindgen_throw */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _wasm_tree_backend_bg_wasm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wasm_tree_backend_bg.wasm */ \"../WasmTreeDataset/wasm-tree-backend/pkg/wasm_tree_backend_bg.wasm\");\n/* harmony import */ var _wasm_tree_backend_bg_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./wasm_tree_backend_bg.js */ \"../WasmTreeDataset/wasm-tree-backend/pkg/wasm_tree_backend_bg.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"TreedDataset\", function() { return _wasm_tree_backend_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"TreedDataset\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbindgen_throw\", function() { return _wasm_tree_backend_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbindgen_throw\"]; });\n\n\n\n\n//# sourceURL=webpack:///../WasmTreeDataset/wasm-tree-backend/pkg/wasm_tree_backend.js?");

/***/ }),

/***/ "../WasmTreeDataset/wasm-tree-backend/pkg/wasm_tree_backend_bg.js":
/*!************************************************************************!*\
  !*** ../WasmTreeDataset/wasm-tree-backend/pkg/wasm_tree_backend_bg.js ***!
  \************************************************************************/
/*! exports provided: TreedDataset, __wbindgen_throw */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TreedDataset\", function() { return TreedDataset; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbindgen_throw\", function() { return __wbindgen_throw; });\n/* harmony import */ var _wasm_tree_backend_bg_wasm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wasm_tree_backend_bg.wasm */ \"../WasmTreeDataset/wasm-tree-backend/pkg/wasm_tree_backend_bg.wasm\");\n\n\nconst lTextDecoder = typeof TextDecoder === 'undefined' ? (0, module.require)('util').TextDecoder : TextDecoder;\n\nlet cachedTextDecoder = new lTextDecoder('utf-8', { ignoreBOM: true, fatal: true });\n\ncachedTextDecoder.decode();\n\nlet cachegetUint8Memory0 = null;\nfunction getUint8Memory0() {\n    if (cachegetUint8Memory0 === null || cachegetUint8Memory0.buffer !== _wasm_tree_backend_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"memory\"].buffer) {\n        cachegetUint8Memory0 = new Uint8Array(_wasm_tree_backend_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"memory\"].buffer);\n    }\n    return cachegetUint8Memory0;\n}\n\nfunction getStringFromWasm0(ptr, len) {\n    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));\n}\n\nfunction isLikeNone(x) {\n    return x === undefined || x === null;\n}\n\nlet cachegetInt32Memory0 = null;\nfunction getInt32Memory0() {\n    if (cachegetInt32Memory0 === null || cachegetInt32Memory0.buffer !== _wasm_tree_backend_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"memory\"].buffer) {\n        cachegetInt32Memory0 = new Int32Array(_wasm_tree_backend_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"memory\"].buffer);\n    }\n    return cachegetInt32Memory0;\n}\n\nlet cachegetUint32Memory0 = null;\nfunction getUint32Memory0() {\n    if (cachegetUint32Memory0 === null || cachegetUint32Memory0.buffer !== _wasm_tree_backend_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"memory\"].buffer) {\n        cachegetUint32Memory0 = new Uint32Array(_wasm_tree_backend_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"memory\"].buffer);\n    }\n    return cachegetUint32Memory0;\n}\n\nfunction getArrayU32FromWasm0(ptr, len) {\n    return getUint32Memory0().subarray(ptr / 4, ptr / 4 + len);\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nfunction passArray32ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 4);\n    getUint32Memory0().set(arg, ptr / 4);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n\nfunction _assertClass(instance, klass) {\n    if (!(instance instanceof klass)) {\n        throw new Error(`expected instance of ${klass.name}`);\n    }\n    return instance.ptr;\n}\n/**\n* A treed dataset is a forest of trees.\n*\n* It is composed of several trees, with a main tree and several optional\n* subtrees.\n*\n* The trees are sorted in different orders, so for each (S?, P?, O?, G?)\n* combinaison (when each S, P ... can be specified or not), we have an\n* efficient way to find every quad that matches the query.\n*\n* Up to 6 different trees are built, with the OGPS tree being built by\n* default\n*/\nclass TreedDataset {\n\n    static __wrap(ptr) {\n        const obj = Object.create(TreedDataset.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    free() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        _wasm_tree_backend_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbg_treeddataset_free\"](ptr);\n    }\n    /**\n    */\n    constructor() {\n        var ret = _wasm_tree_backend_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"treeddataset_new\"]();\n        return TreedDataset.__wrap(ret);\n    }\n    /**\n    * Returns the number of quads\n    * @returns {number}\n    */\n    size() {\n        var ret = _wasm_tree_backend_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"treeddataset_size\"](this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Adds the given quad\n    * @param {number} s\n    * @param {number} p\n    * @param {number} o\n    * @param {number} g\n    */\n    add(s, p, o, g) {\n        _wasm_tree_backend_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"treeddataset_add\"](this.ptr, s, p, o, g);\n    }\n    /**\n    * Removes the given quad\n    * @param {number} s\n    * @param {number} p\n    * @param {number} o\n    * @param {number} g\n    */\n    remove(s, p, o, g) {\n        _wasm_tree_backend_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"treeddataset_remove\"](this.ptr, s, p, o, g);\n    }\n    /**\n    * Returns true if the tree has the specified quad\n    * @param {number} s\n    * @param {number} p\n    * @param {number} o\n    * @param {number} g\n    * @returns {boolean}\n    */\n    has(s, p, o, g) {\n        var ret = _wasm_tree_backend_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"treeddataset_has\"](this.ptr, s, p, o, g);\n        return ret !== 0;\n    }\n    /**\n    * Returns a slice with every quad flattened\n    * @param {number | undefined} s\n    * @param {number | undefined} p\n    * @param {number | undefined} o\n    * @param {number | undefined} g\n    * @returns {Uint32Array}\n    */\n    get_all(s, p, o, g) {\n        _wasm_tree_backend_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"treeddataset_get_all\"](8, this.ptr, !isLikeNone(s), isLikeNone(s) ? 0 : s, !isLikeNone(p), isLikeNone(p) ? 0 : p, !isLikeNone(o), isLikeNone(o) ? 0 : o, !isLikeNone(g), isLikeNone(g) ? 0 : g);\n        var r0 = getInt32Memory0()[8 / 4 + 0];\n        var r1 = getInt32Memory0()[8 / 4 + 1];\n        var v0 = getArrayU32FromWasm0(r0, r1).slice();\n        _wasm_tree_backend_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbindgen_free\"](r0, r1 * 4);\n        return v0;\n    }\n    /**\n    * Builds a new dataset which is built by filtering with the given s, p, o and g.\n    * @param {number | undefined} s\n    * @param {number | undefined} p\n    * @param {number | undefined} o\n    * @param {number | undefined} g\n    * @returns {TreedDataset}\n    */\n    new_from(s, p, o, g) {\n        var ret = _wasm_tree_backend_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"treeddataset_new_from\"](this.ptr, !isLikeNone(s), isLikeNone(s) ? 0 : s, !isLikeNone(p), isLikeNone(p) ? 0 : p, !isLikeNone(o), isLikeNone(o) ? 0 : o, !isLikeNone(g), isLikeNone(g) ? 0 : g);\n        return TreedDataset.__wrap(ret);\n    }\n    /**\n    * @param {Uint32Array} encoded_quads\n    */\n    insert_all_from_slice(encoded_quads) {\n        var ptr0 = passArray32ToWasm0(encoded_quads, _wasm_tree_backend_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbindgen_malloc\"]);\n        var len0 = WASM_VECTOR_LEN;\n        _wasm_tree_backend_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"treeddataset_insert_all_from_slice\"](this.ptr, ptr0, len0);\n    }\n    /**\n    * Builds a TreeDataset from a slice of 4 x u32\n    *\n    * If you have previously extracted a slice from get_all, you can easily build a new dataset with this function\n    * @param {Uint32Array} encoded_quads\n    * @returns {TreedDataset}\n    */\n    static new_from_slice(encoded_quads) {\n        var ptr0 = passArray32ToWasm0(encoded_quads, _wasm_tree_backend_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbindgen_malloc\"]);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _wasm_tree_backend_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"treeddataset_new_from_slice\"](ptr0, len0);\n        return TreedDataset.__wrap(ret);\n    }\n    /**\n    * Removes from the dataset the quads that matches the given pattern\n    * @param {number | undefined} s\n    * @param {number | undefined} p\n    * @param {number | undefined} o\n    * @param {number | undefined} g\n    */\n    deleteMatches(s, p, o, g) {\n        _wasm_tree_backend_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"treeddataset_deleteMatches\"](this.ptr, !isLikeNone(s), isLikeNone(s) ? 0 : s, !isLikeNone(p), isLikeNone(p) ? 0 : p, !isLikeNone(o), isLikeNone(o) ? 0 : o, !isLikeNone(g), isLikeNone(g) ? 0 : g);\n    }\n    /**\n    * @param {TreedDataset} other\n    * @returns {TreedDataset}\n    */\n    insersect(other) {\n        _assertClass(other, TreedDataset);\n        var ret = _wasm_tree_backend_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"treeddataset_insersect\"](this.ptr, other.ptr);\n        return TreedDataset.__wrap(ret);\n    }\n    /**\n    * @param {Uint32Array} other\n    * @returns {TreedDataset}\n    */\n    intersectSlice(other) {\n        var ptr0 = passArray32ToWasm0(other, _wasm_tree_backend_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbindgen_malloc\"]);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _wasm_tree_backend_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"treeddataset_intersectSlice\"](this.ptr, ptr0, len0);\n        return TreedDataset.__wrap(ret);\n    }\n    /**\n    * @param {Uint32Array} other\n    * @returns {TreedDataset}\n    */\n    unionSlice(other) {\n        var ptr0 = passArray32ToWasm0(other, _wasm_tree_backend_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbindgen_malloc\"]);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _wasm_tree_backend_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"treeddataset_unionSlice\"](this.ptr, ptr0, len0);\n        return TreedDataset.__wrap(ret);\n    }\n    /**\n    * @param {Uint32Array} other\n    * @returns {TreedDataset}\n    */\n    differenceSlice(other) {\n        var ptr0 = passArray32ToWasm0(other, _wasm_tree_backend_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbindgen_malloc\"]);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _wasm_tree_backend_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"treeddataset_differenceSlice\"](this.ptr, ptr0, len0);\n        return TreedDataset.__wrap(ret);\n    }\n    /**\n    * @param {TreedDataset} other\n    * @returns {TreedDataset}\n    */\n    union(other) {\n        _assertClass(other, TreedDataset);\n        var ret = _wasm_tree_backend_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"treeddataset_union\"](this.ptr, other.ptr);\n        return TreedDataset.__wrap(ret);\n    }\n    /**\n    * @param {TreedDataset} other\n    * @returns {TreedDataset}\n    */\n    difference(other) {\n        _assertClass(other, TreedDataset);\n        var ret = _wasm_tree_backend_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"treeddataset_difference\"](this.ptr, other.ptr);\n        return TreedDataset.__wrap(ret);\n    }\n    /**\n    * @param {TreedDataset} other\n    * @returns {boolean}\n    */\n    contains(other) {\n        _assertClass(other, TreedDataset);\n        var ret = _wasm_tree_backend_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"treeddataset_contains\"](this.ptr, other.ptr);\n        return ret !== 0;\n    }\n    /**\n    * @param {Uint32Array} other\n    * @returns {boolean}\n    */\n    containsSlice(other) {\n        var ptr0 = passArray32ToWasm0(other, _wasm_tree_backend_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbindgen_malloc\"]);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _wasm_tree_backend_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"treeddataset_containsSlice\"](this.ptr, ptr0, len0);\n        return ret !== 0;\n    }\n    /**\n    * @param {Uint32Array} other\n    * @returns {boolean}\n    */\n    equalsSlice(other) {\n        var ptr0 = passArray32ToWasm0(other, _wasm_tree_backend_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbindgen_malloc\"]);\n        var len0 = WASM_VECTOR_LEN;\n        var ret = _wasm_tree_backend_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"treeddataset_equalsSlice\"](this.ptr, ptr0, len0);\n        return ret !== 0;\n    }\n    /**\n    * @param {TreedDataset} other\n    * @returns {boolean}\n    */\n    has_same_elements(other) {\n        _assertClass(other, TreedDataset);\n        var ret = _wasm_tree_backend_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"treeddataset_has_same_elements\"](this.ptr, other.ptr);\n        return ret !== 0;\n    }\n    /**\n    * Counts the number of quads that matches the given pattern\n    * @param {number | undefined} s\n    * @param {number | undefined} p\n    * @param {number | undefined} o\n    * @param {number | undefined} g\n    * @returns {number}\n    */\n    match_count(s, p, o, g) {\n        var ret = _wasm_tree_backend_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"treeddataset_match_count\"](this.ptr, !isLikeNone(s), isLikeNone(s) ? 0 : s, !isLikeNone(p), isLikeNone(p) ? 0 : p, !isLikeNone(o), isLikeNone(o) ? 0 : o, !isLikeNone(g), isLikeNone(g) ? 0 : g);\n        return ret >>> 0;\n    }\n}\n\nconst __wbindgen_throw = function(arg0, arg1) {\n    throw new Error(getStringFromWasm0(arg0, arg1));\n};\n\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../navbench/node_modules/webpack/buildin/harmony-module.js */ \"./node_modules/webpack/buildin/harmony-module.js\")(module)))\n\n//# sourceURL=webpack:///../WasmTreeDataset/wasm-tree-backend/pkg/wasm_tree_backend_bg.js?");

/***/ }),

/***/ "../WasmTreeDataset/wasm-tree-backend/pkg/wasm_tree_backend_bg.wasm":
/*!**************************************************************************!*\
  !*** ../WasmTreeDataset/wasm-tree-backend/pkg/wasm_tree_backend_bg.wasm ***!
  \**************************************************************************/
/*! exports provided: memory, __wbg_treeddataset_free, treeddataset_new, treeddataset_size, treeddataset_add, treeddataset_remove, treeddataset_has, treeddataset_get_all, treeddataset_new_from, treeddataset_insert_all_from_slice, treeddataset_new_from_slice, treeddataset_deleteMatches, treeddataset_insersect, treeddataset_intersectSlice, treeddataset_unionSlice, treeddataset_differenceSlice, treeddataset_union, treeddataset_difference, treeddataset_contains, treeddataset_containsSlice, treeddataset_equalsSlice, treeddataset_has_same_elements, treeddataset_match_count, __wbindgen_free, __wbindgen_malloc */
/***/ (function(module, exports, __webpack_require__) {

eval("\"use strict\";\n// Instantiate WebAssembly module\nvar wasmExports = __webpack_require__.w[module.i];\n__webpack_require__.r(exports);\n// export exports from WebAssembly module\nfor(var name in wasmExports) if(name != \"__webpack_init__\") exports[name] = wasmExports[name];\n// exec imports from WebAssembly module (for esm order)\n/* harmony import */ var m0 = __webpack_require__(/*! ./wasm_tree_backend_bg.js */ \"../WasmTreeDataset/wasm-tree-backend/pkg/wasm_tree_backend_bg.js\");\n\n\n// exec wasm module\nwasmExports[\"__webpack_init__\"]()\n\n//# sourceURL=webpack:///../WasmTreeDataset/wasm-tree-backend/pkg/wasm_tree_backend_bg.wasm?");

/***/ }),

/***/ "../WasmTreeDataset/wasm-tree-frontend/index.js":
/*!******************************************************!*\
  !*** ../WasmTreeDataset/wasm-tree-frontend/index.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("let graphyFactory = __webpack_require__(/*! @graphy/core.data.factory */ \"../WasmTreeDataset/wasm-tree-frontend/node_modules/@graphy/core.data.factory/main.js\");\nconst rust = __webpack_require__(/*! ../wasm-tree-backend/pkg */ \"../WasmTreeDataset/wasm-tree-backend/pkg/wasm_tree_backend.js\");\nconst EventEmitter = __webpack_require__(/*! events */ \"./node_modules/events/events.js\");\nconst { Readable } = __webpack_require__(/*! stream */ \"./node_modules/stream-browserify/index.js\");\n\n// TODO : convert every_snake_case_name into camelCase\n\n/**\n * Returns true if expr is undefined or null\n * @param {*} expr \n */\nfunction isLikeNone(expr) {\n    return expr === undefined || expr === null;\n}\n\n/**\n * A class that maps terms with numbers.\n * The mapping resorts to Graphy's concise terms and Javascript maps.\n * \n * Mapped terms are never destroyed from the map\n */\nclass Indexer {\n    /**\n     * Constructs an indexer with the default graph as the 0th term\n     */\n    constructor() {\n        this.indexToTerms = [graphyFactory.defaultGraph()];\n        this.termsToIndex = {};\n        this.termsToIndex[graphyFactory.defaultGraph().concise()] = 0;\n        this.nextValue = 1;\n    }\n\n    /**\n     * Returns the graphy term bound to this index\n     * @param {number} index The index\n     */\n    getTerm(index) {\n        return this.indexToTerms[index];\n    }\n\n    /**\n     * Returns the index of the given term, or 0 if not mapped\n     * @param {Object} term The term\n     */\n    findIndex(term) {\n        let graphyTerm = graphyFactory.fromTerm(term);\n        let concise = graphyTerm.concise();\n        return this.termsToIndex[concise];\n    }\n\n    /**\n     * Returns the index of the given term. If not present, it will be added in\n     * the indexer.\n     * @param {Object} term The term\n     */\n    findOrAddIndex(term) {\n        let graphyTerm = graphyFactory.fromTerm(term);\n        let concise = graphyTerm.concise();\n        let r = this.termsToIndex[concise];\n        if (r !== undefined) {\n            return r;\n        } else {\n            let index = this.nextValue;\n            this.termsToIndex[concise] = index;\n            this.indexToTerms.push(graphyTerm);\n            this.nextValue += 1;\n            return index;\n        }\n    }\n\n    /**\n     * Returns an array of four indexes, corresponding to the terms from the\n     * quad. If a term is not known yet, a new index will be created\n     * @param {Object} quad A RDF.JS compliant quad\n     */\n    findOrAddIndexes(quad) {\n        return [\n            this.findOrAddIndex(quad.subject),\n            this.findOrAddIndex(quad.predicate),\n            this.findOrAddIndex(quad.object),\n            this.findOrAddIndex(quad.graph)\n        ];\n    }\n\n    /**\n     * Returns an array of four indexes, corresponding to the terms from the\n     * quad. If a term is not known yet, null will be returned\n     * @param {Object} quad A RDF.JS compliant quad\n     */\n    findIndexes(quad) {\n        let quadIndexes = [\n            this.findIndex(quad.subject),\n            this.findIndex(quad.predicate),\n            this.findIndex(quad.object),\n            this.findIndex(quad.graph)\n        ];\n\n        for (let i = 0 ; i != 4 ; i++) {\n            if (quadIndexes[i] === undefined) {\n                return null;\n            }\n        }\n\n        return quadIndexes;\n    }\n\n    /**\n     * Returns a RDF.JS quad if the passed indexes exist, null if one of them\n     * does not\n     * @param {*} spog An array of four indexes. Its content is altered by\n     * this function.\n     */\n    getQuad(spog) {\n        for (let i = 0 ; i != 4 ; ++i) {\n            spog[i] = this.getTerm(spog[i]);\n            if (spog[i] === undefined) return null;\n        }\n\n        return graphyFactory.quad(spog[0], spog[1], spog[2], spog[3]);\n    }\n\n    /**\n     * Write in the array at position [startingPosition:startingPosition+4] the\n     * index of the subject, the predicate, the object and the graph of the\n     * given quad.\n     * \n     * This function has been created to be able to store indexes without creating\n     * a temporary array like the findOrAddIndexes method\n     * @param {*} array An array (or an array like structure) in which the\n     * indexes will be written\n     * @param {Number} startingPosition Position where the subject index will be\n     * written\n     * @param {*} quad The RDF.JS compliant quad\n     */\n    writeTermIndexesIn(array, startingPosition, quad) {\n        array[startingPosition + 0] = this.findOrAddIndex(quad.subject)\n        array[startingPosition + 1] = this.findOrAddIndex(quad.predicate)\n        array[startingPosition + 2] = this.findOrAddIndex(quad.object)\n        array[startingPosition + 3] = this.findOrAddIndex(quad.graph)\n    }\n\n    /**\n     * Push the index of quad terms in the given array\n     * @param {*} array The array to fill\n     * @param {*} quad The RDF.JS quad to insert in the list of term indexes\n     */\n    pushTermIndexesIn(array, quad) {\n        array.push(this.findOrAddIndex(quad.subject));\n        array.push(this.findOrAddIndex(quad.predicate));\n        array.push(this.findOrAddIndex(quad.object));\n        array.push(this.findOrAddIndex(quad.graph));\n    }\n\n    /**\n     * Build an array that is suitable to pass to a wasm tree that uses\n     * the indexes described by this indexer for the intersection function (or\n     * any function that results in a dataset that will contains some of the\n     * quad of the original dataset and no extra quad)\n     * @param {*} dataset The other dataset\n     */\n    buildSliceForIntersection(dataset) {\n        let array = [];\n\n        for (let quad of dataset) {\n            let indexes = this.findIndexes(quad);\n            if (indexes != null) {\n                array.push(...indexes);\n            }\n        }\n\n        return array;\n    }\n\n    /**\n     * Build an array that is suitable to pass to a wasm tree that uses\n     * the indexes described by this indexer for the union function (or\n     * any function that results in a dataset that will contains quads\n     * frorm the current and/or the other dataset)\n     * @param {*} dataset The other dataset\n     */\n    buildSliceForUnion(dataset) {\n        const length = dataset.length;\n        if (isLikeNone(length)) {\n            // We do not know in advance the length of the dataset. Only use the iterator\n            let array = [];\n\n            for (let quad of dataset) {\n                this.pushTermIndexesIn(array, quad);\n            }\n\n            return array;\n        } else {\n            let array = new Array(dataset.length * 4);\n\n            let i = 0;\n            for (let quad of dataset) {\n                this.writeTermIndexesIn(array, i, quad);\n                i += 4;\n            }\n\n            return array;\n        }\n    }\n\n    /**\n     * Builds a list of terms represented by their index from a list of RDF.JS\n     * quads. If a term has no known index, null is returned instead.\n     * @param {*} dataset A list of RDF.JS quads\n     */\n    buildSliceForEquals(dataset) {\n        let array = [];\n\n        for (let quad of dataset) {\n            let indexes = this.findIndexes(quad);\n            if (indexes != null) {\n                array.push(...indexes);\n            } else {\n                return null;\n            }\n        }\n\n        return array;\n    }\n\n    /**\n     * Transforms the subject, predicate, object and graph received as Terms\n     * into indexes. If a matching could not be done, returns null. Else,\n     * returns an array with the indexes or null/undefined when the term was\n     * already null or undefined.\n     * \n     * @param {?Term} subject \n     * @param {?Term} predicate \n     * @param {?Term} object \n     * @param {?Term} graph \n     */\n    _matchIndexes(subject, predicate, object, graph) {\n        if (!isLikeNone(subject)) {\n            subject = this.findIndex(subject);\n            if (isLikeNone(subject)) return null;\n        }\n\n        if (!isLikeNone(predicate)) {\n            predicate = this.findIndex(predicate);\n            if (isLikeNone(predicate)) return null;\n        }\n\n        if (!isLikeNone(object)) {\n            object = this.findIndex(object);\n            if (isLikeNone(object)) return null;\n        }\n\n        if (!isLikeNone(graph)) {\n            graph = this.findIndex(graph);\n            if (isLikeNone(graph)) return null;\n        }\n\n        return [subject, predicate, object, graph]\n    }\n}\n\n/** An iterator on a Wrapped Tree */\nclass WrappedTreeIterator {\n    constructor(wrappedTree) {\n        this.index = 0;\n        this.data = wrappedTree._get_slice();\n        this.indexer = wrappedTree.indexer;\n        this.wrappedTree = wrappedTree;\n    }\n\n    next() {\n        if (this.index >= this.data.length) {\n            return { value: null, done: true };\n        } else {\n            let spogIndexes = [\n                this.data[this.index],\n                this.data[this.index + 1],\n                this.data[this.index + 2],\n                this.data[this.index + 3]\n            ];\n            \n            let value = this.indexer.getQuad(spogIndexes);\n            this.index += 4;\n\n            return { value: value, done: false };\n        }\n    }\n\n    filterInUInt32Array(quadFilterIteratee) {\n        const resultArrayLength = this.data.length - this.index;\n        let resultingArray = new Uint32Array(resultArrayLength);\n\n        // Filtering process\n        let i = 0;\n        while (true) {\n            let it = this.next();\n            if (it.done) {\n                break;\n            }\n\n            if (quadFilterIteratee(it.value, this.wrappedTree)) {\n                // We could do a look up of the terms from it.value, but can\n                // just look back the term indexes\n                resultingArray[i + 0] = this.data[this.index - 4 + 0];\n                resultingArray[i + 1] = this.data[this.index - 4 + 1];\n                resultingArray[i + 2] = this.data[this.index - 4 + 2];\n                resultingArray[i + 3] = this.data[this.index - 4 + 3];\n\n                i += 4;\n            }\n        }\n\n        // Reducing the array\n        if (i != resultArrayLength) {\n            const SMALL_ARRAY_LENGTH = 256;\n\n            if (i / 4 < resultArrayLength || (i <= SMALL_ARRAY_LENGTH)) {\n                // For small resulting arrays, we copy the slice\n                resultingArray = resultingArray.slice(0, i);\n            } else {\n                // Else we keep the same buffer but we correct the considered size\n                resultingArray = resultingArray.subarray(0, i);\n            }\n        }\n\n        return resultingArray;\n    }\n\n    /**\n     * Builds a Uint32Array which contains the list of term indexes of the quad\n     * obtained by applying to them the quadMapIteratee function.\n     * \n     * The returned Uint32Array may contain duplicated quads depending on the\n     * quadMapIteratee function.\n     */\n    mapInUInt32Array(quadMapIteratee) {\n        let resultingArray = new Uint32Array(this.data.length - this.index);\n\n        let i = 0;\n        while (true) {\n            let it = this.next();\n            if (it.done) {\n                break;\n            }\n\n            let mappedQuad = quadMapIteratee(it.value, this.wrappedTree);\n            this.indexer.writeTermIndexesIn(resultingArray, i, mappedQuad);\n            i += 4;\n        }\n\n        return resultingArray;\n    }\n}\n\n/**\n * A RDF.JS DatasetCore that resorts on a wasm exported structure that\n * uses several TreeSet and an Indexer.\n */\nclass TreeDataset {\n    /**\n     * Constructs a Wrapped Tree\n     * \n     * slice and tree arguments are used only if an indexer is provided\n     * @param {*} indexer If provided, the indexer to uses\n     * @param {*} slice If provided, some numbers that represents the quads.\n     * @param {*} tree If provided the used tree\n     */\n    constructor(indexer, slice, tree) {\n        if (indexer === undefined) {\n            this.indexer = new Indexer();\n            this.tree = new rust.TreedDataset();\n            this.slice = undefined;\n        } else {\n            this.indexer = indexer;\n            this.tree = tree;\n            this.slice = slice === null ? undefined : slice;\n        }\n    }\n\n    /** Falls back to the tree structure if a slice is owned */\n    _ensure_has_tree() {\n        if (this.tree === undefined) {\n            if (this.slice !== undefined) {\n                this.tree = rust.TreedDataset.new_from_slice(this.slice);\n            } else {\n                this.tree = new rust.TreedDataset();\n            }\n        }\n    }\n\n    /** Ensures a tree is owned and no slice is owned */\n    _ensure_has_modifiable_tree() {\n        this._ensure_has_tree();\n        this.slice = undefined;\n    }\n\n    /**\n     * Liberates the memory allocated by wasm for the tree and empties the tree\n     */\n    free() {\n        if (this.tree !== undefined) {\n            this.tree.free();\n            this.tree = undefined;\n        }\n\n        this.slice = undefined;\n    }\n\n    // ========================================================================\n    // ==== RDF.JS DatasetCore Implementation\n    // ==== https://rdf.js.org/dataset-spec/#datasetcore-interface\n\n    /**\n     * Returns the number of contained elements.\n     */\n    get size() {\n        if (this.slice !== undefined) {\n            return this.slice.length / 4;\n        } else if (this.tree !== undefined) {\n            return this.tree.size();\n        } else {\n            return 0;\n        }\n    }\n\n    [Symbol.iterator]() {\n        return new WrappedTreeIterator(this);\n    }\n\n    /**\n     * Adds the quad to the dataset\n     * @param {*} quad \n     */\n    add(quad) {\n        this._ensure_has_modifiable_tree();\n\n        let quadIndexes = this.indexer.findOrAddIndexes(quad);\n        this.tree.add(quadIndexes[0], quadIndexes[1], quadIndexes[2], quadIndexes[3]);\n        return this;\n    }\n\n    /**\n     * Removes the quad from the dataset\n     * @param {*} quad \n     */\n    delete(quad) {\n        let quadIndexes = this.indexer.findIndexes(quad);\n\n        if (quadIndexes !== null) {\n            this._ensure_has_modifiable_tree();\n            this.tree.remove(quadIndexes[0], quadIndexes[1], quadIndexes[2], quadIndexes[3]);\n        }\n\n        return this;\n    }\n\n    /**\n     * Returns true if the dataset contains the quad\n     * @param {*} quad \n     */\n    has(quad) {\n        let quadIndexes = this.indexer.findIndexes(quad);\n\n        if (quadIndexes === null) {\n            return false;\n        } else {\n            // TODO : if we have a slice, we could try to ask to rust to find the quad (but beware of copy)\n            // Note : Even if a copy is done, we could create another state which is \"Rust owns a copy\"\n            this._ensure_has_tree();\n            return this.tree.has(quadIndexes[0], quadIndexes[1], quadIndexes[2], quadIndexes[3]);\n        }\n    }\n\n    /**\n     * Returns a new dataset with the specified subject, predicate, object and\n     * graph, if provided\n     * @param {*} subject The subject or null\n     * @param {*} predicate The predicate or null\n     * @param {*} object The object or null\n     * @param {*} graph The graph or null\n     */\n    match(subject, predicate, object, graph) {\n        // Rewrite match parameters with indexes\n        let matchResult = this.indexer._matchIndexes(subject, predicate, object, graph);\n        if (matchResult === null) {\n            return new TreeDataset(this.indexer);\n        }\n\n        // Match is valid\n        this._ensure_has_tree();\n        let slice = this.tree.get_all(matchResult[0], matchResult[1], matchResult[2], matchResult[3]);\n        return new TreeDataset(this.indexer, slice);\n    }\n\n    // ========================================================================\n    // ==== RDF.JS Dataset Partial Implementation\n    // ==== https://rdf.js.org/dataset-spec/#dataset-interface\n\n    // == DELETE MATCHES\n    // This function mainly resorts on the web assembly back end and there is\n    // little to do in Javascript\n\n    /**\n     * Removes from the dataset the quad that matches the arguments using the\n     * Quad Matching logic described in\n     * https://rdf.js.org/dataset-spec/#quad-matching\n     * @param {?Term} subject The subject of the quads to remove, or null / undefined\n     * @param {?Term} predicate The predicate of the quads to remove, or null / undefined\n     * @param {?Term} object The object of the quads to remove, or null / undefined\n     * @param {?Term} graph The graph of the quads to remove, or null / undefined\n     */\n    deleteMatches(subject, predicate, object, graph) {\n        let matchResult = this.indexer._matchIndexes(subject, predicate, object, graph);\n        if (matchResult === null) {\n            return this;\n        }\n\n        this._ensure_has_modifiable_tree();\n        this.tree.deleteMatches(matchResult[0], matchResult[1], matchResult[2], matchResult[3]);\n        return this;\n    }\n    \n    // == SLICE EXPLOITATION\n    // Theses functions requires Web Assembly to return the whole array of\n    // indexes and do all the operation in Javascript.\n    //\n    // They are implemented with the naive way because they heavily resorts on\n    // Javascript closures\n\n    /**\n     * Returns a slice with every quads in a format of an array of integers with\n     * `[s1, p1, o1, g1, s2, p2, o2, g3, ..., sn, pn, on, gn]`\n     * where s1 is the subject of the first quad, p1 the predicate of the first\n     * quad, ... and gn the graph of the last quad.\n     */\n    _get_slice() {\n        if (this.slice === undefined) {\n            if (this.tree === undefined) {\n                return [];\n            } else {\n                return this.tree.get_all(null, null, null, null);\n            }\n        } else {\n            return this.slice;\n        }\n    }\n\n    /**\n     * Returns an array with the quads in this dataset\n     */\n    toArray() {\n        return Array.from(this[Symbol.iterator]);\n    }\n\n    /**\n     * Returns true if every quad of the dataset returns true when passed as an\n     * argument to quadFilterIteratee\n     * @param {*} quadFilterIteratee The function to pass to the quads\n     */\n    every(quadFilterIteratee) {\n        // We can not do better than a naive implementation with our backend\n        for (let quad of this) {\n            if (!quadFilterIteratee(quad)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Returns true if at least one quad of the dataset returns true when\n     * called on the passed quad\n     * @param {*} quadFilterIteratee \n     */\n    some(quadFilterIteratee) {\n        // We can not do better than a naive implementation with our backend\n        for (let quad of this) {\n            if (quadFilterIteratee(quad)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Calls the quadRunIteratee function with every quad in the dataset\n     * @param {*} quadRunIteratee \n     */\n    forEach(quadRunIteratee) {\n        // We can not do better than a naive implementation with our backend\n        for (let quad of this) {\n            quadRunIteratee(quad);\n        }\n    }\n\n    /**\n     * Reduce the dataset into a value using the quadReduceIteratee function.\n     * And initial value can be provided, else, the value of the first iterated\n     * quad will be used\n     * @param {*} quadReduceIteratee The reduce function\n     * @param {?any} initialValue The initial value, if undefined the first quad\n     * will be used as an initial value\n     */\n    reduce(quadReduceIteratee, initialValue) {\n        // We can not do better than a naive implementation with our backend\n        let isFirst = true;\n\n        for (let quad of this) {\n            if (isFirst) {\n                if (initialValue === undefined) {\n                    initialValue = quad;\n                } else {\n                    initialValue = quadReduceIteratee(initialValue, quad);    \n                }\n\n                isFirst = false;\n            } else {\n                initialValue = quadReduceIteratee(initialValue, quad);\n            }\n        }\n\n        return initialValue;\n    }\n\n    // == DATASET CREATORS FROM FUNCTIONS\n    // These functions creates a new dataset after using a function on every\n    // quad of this dataset.\n    //\n    // We have to get every quads from this dataset, and pass them to the\n    // function.\n\n    /**\n     * Produces a new dataset that is composed of the quad of this dataset that\n     * returns true when applied to the passed function\n     * @param {*} quadFilterIteratee The function\n     */\n    filter(quadFilterIteratee) {\n        let resultingArray = new WrappedTreeIterator(this).filterInUInt32Array(quadFilterIteratee);\n\n        // The resulting array is a valid dataset for our structure, so we do\n        // not fall back to wasm backend.\n        return new TreeDataset(this.indexer, resultingArray);\n    }\n\n    /**\n     * Produces a new dataset by applying to the quads the quadMapIteratee\n     * function\n     * @param {*} quadMapIteratee \n     */\n    map(quadMapIteratee) {\n        let resultingArray = new WrappedTreeIterator(this).mapInUInt32Array(quadMapIteratee);\n        \n        // Return the new tree :\n        // We can not return the tree with just the resultingArray as it may\n        // contain duplicated quads (for example if the map function always\n        // returns the same quad). To filter duplicated quad, we integrate the\n        // slice into a Wasm managed tree (which resorts on Rust's BTreeSet)\n        // Conveniently, the `_ensure_has_modifiable_tree` function produces\n        // exactly this behaviour.\n        let newWrappedTree = new TreeDataset(this.indexer, resultingArray);\n        newWrappedTree._ensure_has_modifiable_tree();\n        return newWrappedTree;\n    }\n\n\n    // == ENSEMBLIST OPERATIONS\n\n    static get SIMILARITY_NONE() { return 0; }\n    static get SIMILARITY_SAME_CLASS() { return 1; }\n    static get SIMILARITY_SAME_INDEXER() { return 2; }\n\n    /**\n     * Return :\n     * - 0 if the other dataset is not an instance of TreeDataset\n     * - 1 if the other dataset is an instance of TreeDataset but does not\n     * share its indexer object with other\n     * - 2 if both this dataset and the other dataset are instances of Wrapped\n     * Tree and share the indexer object\n     * @param {*} other The other dataset\n     */\n    _get_degree_of_similarity(other) {\n        if (this._are_both_wrapped_trees != other._are_both_wrapped_trees) {\n            // Different class\n            return TreeDataset.SIMILARITY_NONE;\n        } else if (this.indexer != other.indexer) {\n            // Different indexer\n            return TreeDataset.SIMILARITY_SAME_CLASS;\n        } else {\n            // Same class and same indexer which means we can rely on a pure Rust implementation\n            return TreeDataset.SIMILARITY_SAME_INDEXER;\n        }\n    }\n\n    _operationWithAnotherDataset(other, functionToCallIfSame, functionToCallIfDifferent, finalize) {\n        this._ensure_has_tree();\n\n        let similarity = this._get_degree_of_similarity(other);\n\n        if (similarity == TreeDataset.SIMILARITY_SAME_INDEXER) {\n            other._ensure_has_tree();\n            return finalize(this, functionToCallIfSame(this, other));\n        } else {\n            return finalize(this, functionToCallIfDifferent(this, other));\n        }\n    }\n\n    /**\n     * Returns a dataset which is the intersection of this dataset and the\n     * other dataset\n     * @param {DatasetCore} other The dataset to intersect with\n     */\n    intersection(other) {\n        return this._operationWithAnotherDataset(other,\n            (lhs, rhs) => lhs.tree.insersect(rhs.tree),\n            (lhs, rhs) => {\n                let rhsSlice = lhs.indexer.buildSliceForIntersection(rhs);\n                return lhs.tree.intersectSlice(rhsSlice);\n            },\n            (lhs, tree) => new TreeDataset(lhs.indexer, undefined, tree)\n        );\n    }\n\n    /**\n     * Return a new dataset that is the difference between this one and the passed dataset\n     * @param {*} other The other dataset\n     */\n    difference(other) {\n        return this._operationWithAnotherDataset(other,\n            (lhs, rhs) => lhs.tree.difference(rhs.tree),\n            (lhs, rhs) => {\n                let rhsSlice = lhs.indexer.buildSliceForIntersection(rhs);\n                return lhs.tree.differenceSlice(rhsSlice);\n            },\n            (lhs, tree) => new TreeDataset(lhs.indexer, undefined, tree)\n        );\n    }\n\n    /**\n     * Returns a new dataset that is the union of this dataset and the other\n     * dataset\n     * @param {*} other The other dataset\n     */\n    union(other) {\n        return this._operationWithAnotherDataset(other,\n            (lhs, rhs) => lhs.tree.union(rhs.tree),\n            (lhs, rhs) => {\n                let rhsSlice = lhs.indexer.buildSliceForUnion(rhs);\n                return lhs.tree.unionSlice(rhsSlice);\n            },\n            (lhs, tree) => new TreeDataset(lhs.indexer, undefined, tree)\n        );\n    }\n    \n    /**\n     * Returns true if this dataset contains the other (in other words, if\n     * every quad from the other dataset is in this dataset)\n     * @param {*} other The contained dataset\n     */\n    contains(other) {\n        return this._operationWithAnotherDataset(other,\n            (lhs, rhs) => lhs.tree.contains(rhs.tree),\n            (lhs, rhs) => {\n                let rhsSlice = lhs.indexer.buildSliceForEquals(rhs);\n                if (rhsSlice == null) {\n                    return false;\n                } else {\n                    return lhs.tree.containsSlice(rhsSlice);\n                }\n            },\n            (_, answer) => answer\n        );\n    }\n\n    /**\n     * Returns true if this and the other dataset are equals.\n     * Blank nodes are not normalized, so two datasets are considered equals\n     * iif every term have the same identifier\n     * \n     * @param {*} other The other dataset\n     */\n    equals(other) {\n        return this._operationWithAnotherDataset(other,\n            (lhs, rhs) => lhs.tree.has_same_elements(rhs.tree),\n            (lhs, rhs) => {\n                let rhsSlice = lhs.indexer.buildSliceForEquals(rhs);\n                if (rhsSlice == null) {\n                    return false;\n                } else {\n                    return lhs.tree.equalsSlice(rhsSlice);\n                }\n            },\n            (_, answer) => answer\n        );\n    }\n\n    // == ALMOST ENSEMBLIST OPERATION\n\n    /**\n     * Adds every quad from the other dataset (or sequence of quads) in this\n     * dataset\n     * @param {*} other The source sequence of quads or a dataset\n     */\n    addAll(other) {\n        this._operationWithAnotherDataset(other,\n            (lhs, rhs) => lhs.tree.addAll(rhs.tree),\n            (lhs, rhs) => {\n                // As buildSliceForUnion use the fact that a RDF.JS dataset\n                // have to implement Iterable<Quad>, a Sequence<Quad> can\n                // also be passed to buildSliceForUnion.\n                let rhsSlice = lhs.indexer.buildSliceForUnion(rhs);\n                lhs.tree.insert_all_from_slice(rhsSlice);\n            },\n            (_1, _2) => { return; }\n        );\n    }\n\n    // Promise<Dataset>                  import (Stream stream);\n    // Stream                            toStream ();\n\n    // ==== LEFTOVER FUNCTIONS\n    // aka why we are not a RDF.JS Dataset\n\n    // String                            toCanonical ();\n    // String                            toString ();\n\n    // ==== OTHER FUNCTIONS\n\n    /**\n     * Returns the number of quads that will match the given pattern\n     * May be used for SPARQL query planning\n     * \n     * @param {*} subject Required subject or null \n     * @param {*} predicate Required predicate or null\n     * @param {*} object Required object or null\n     * @param {*} graph Required graph or null\n     */\n    matchCount(subject, predicate, object, graph) {\n        if (this.tree === undefined && this.slice === undefined) return 0;\n\n        this._ensure_has_tree();\n\n        let matchResult = this.indexer._matchIndexes(subject, predicate, object, graph);\n        if (matchResult == null) {\n            return 0;\n        } else {\n            return this.tree.match_count(matchResult[0], matchResult[1], matchResult[2], matchResult[3]);\n        }\n    }\n}\n\n// ============================================================================\n// ============================================================================\n// ==== Store Implementation\n\n/** Launch an asynchronous function */\nfunction asyncCall(functionToAsync) {\n    // Source : https://stackoverflow.com/a/17361722\n    setTimeout(functionToAsync, 0);\n}\n\n\n/**\n * A Stream of Quads with the elements contained in the passed slice\n */\nclass WasmTreeStoreMatch extends Readable {\n    constructor(indexer, slice) {\n        super({ \"objectMode\": true });\n        this.slice = slice;\n        this.indexer = indexer;\n        this.index = 0;\n    }\n\n    _read() {\n        if (this.index >= this.slice.length) {\n            this.push(null);\n        } else {\n            let spogIndexes = [\n                this.slice[this.index],\n                this.slice[this.index + 1],\n                this.slice[this.index + 2],\n                this.slice[this.index + 3]\n            ];\n\n            this.index += 4;\n\n            this.push(this.indexer.getQuad(spogIndexes));\n        }\n    }\n}\n\n/**\n * A RDF.JS compliant store (http://rdf.js.org/stream-spec/) that resorts to a\n * backend which is a tree structure in Web Assembly and a frontend which is a\n * Javascript map with a correspondance between RDF.JS terms and indexes\n * (numbers). \n */\nclass TreeStore {\n    /**\n     * Builds an empty store\n     */\n    constructor() {\n        this.tree = new rust.TreedDataset();\n        this.indexer = new Indexer();\n    }\n\n    /**\n     * Ensures a backend tree is created\n     */\n    _ensure_has_tree() {\n        if (this.tree === null) {\n            this.tree = new rust.TreedDataset();\n        }\n    }\n\n    /**\n     * Returns a read stream with every quad from this store that matches the\n     * given pattern\n     * @param {*} subject Required subject or null \n     * @param {*} predicate Required predicate or null\n     * @param {*} object Required object or null\n     * @param {*} graph Required graph or null\n     */\n    match(subject, predicate, object, graph) {\n        if (this.tree === null) return new WasmTreeStoreMatch(this.indexer, []);\n\n        let matchResult = this.indexer._matchIndexes(subject, predicate, object, graph);\n        if (matchResult == null) {\n            return new WasmTreeStoreMatch(this.indexer, []);\n        } else {\n            let slice = this.tree.get_all(matchResult[0], matchResult[1], matchResult[2], matchResult[3]);\n            return new WasmTreeStoreMatch(this.indexer, slice)\n        }\n    }\n\n    /**\n     * Synchronously returns the number of quads that will match the given pattern\n     * @param {*} subject Required subject or null \n     * @param {*} predicate Required predicate or null\n     * @param {*} object Required object or null\n     * @param {*} graph Required graph or null\n     */\n    matchCount(subject, predicate, object, graph) {\n        if (this.tree === null) return 0;\n\n        let matchResult = this.indexer._matchIndexes(subject, predicate, object, graph);\n        if (matchResult == null) {\n            return 0;\n        } else {\n            return this.tree.match_count(matchResult[0], matchResult[1], matchResult[2], matchResult[3]);\n        }\n    }\n\n    /**\n     * Adds in this store every quad from the given stream of quads.\n     * @param {*} streamOfQuads The stream of quads\n     */\n    import(streamOfQuads) {\n        this._ensure_has_tree();\n        let that = this;\n\n        streamOfQuads.on('data', quad => {\n            let quadIndexes = that.indexer.findOrAddIndexes(quad);\n            that.tree.add(quadIndexes[0], quadIndexes[1], quadIndexes[2], quadIndexes[3]);\n        });\n\n        return streamOfQuads;\n    }\n\n    /**\n     * Removes from this store every quad in the given stream of quads\n     * @param {*} streamOfQuads The stream of quads to remove\n     */\n    remove(streamOfQuads) {\n        // TODO : a valid strategy would be to batch remove the quads from the\n        // rust dataset using a buffer and the end event to remove the last\n        // buffered quads\n        let that = this;\n\n        streamOfQuads.on('data', quad => {\n            if (that.tree === null) return;\n\n            let quadIndexes = that.indexer.findIndexes(quad);\n\n            if (quadIndexes !== null) {\n                that.tree.remove(quadIndexes[0], quadIndexes[1], quadIndexes[2], quadIndexes[3]);\n            }\n        });\n\n        return streamOfQuads;\n    }\n\n    /**\n     * Removes from this store every quad that matches the given pattern.\n     * @param {*} subject The subject or null\n     * @param {*} predicate The predicate or null\n     * @param {*} object The object or null\n     * @param {*} graph The graph or null\n     */\n    removeMatches(subject, predicate, object, graph) {\n        let eventEmitter = new EventEmitter();\n\n        let matchResult = this.indexer._matchIndexes(subject, predicate, object, graph);\n        if (matchResult == null) {\n            eventEmitter.emit('end');\n        } else {\n            let that = this;\n            \n            asyncCall(() => {\n                if (that.tree !== null) {\n                    that.tree.deleteMatches(matchResult[0], matchResult[1], matchResult[2], matchResult[3]);\n                }\n                eventEmitter.emit('end');\n            });\n        }\n\n        return eventEmitter;\n    }\n\n    /**\n     * Removes every quad in the given graph\n     * @param {*} graph A string or the RDF.JS term corresponding to the graph to remove\n     */\n    deleteGraph(graph) {\n        if (Object.prototype.toString.call(graph) === \"[object String]\") {\n            // TODO : we could directly concise the graph name instead of using an intermediate NamedNode\n            graph = graphyFactory.namedNode(graph);\n        }\n\n        return this.removeMatches(null, null, null, graph);\n    }\n\n    /**\n     * Synchronously liberates the memory assigned to this tree by the Web\n     * Assembly linear memory and empty the store.\n     */\n    free() {\n        if (this.tree !== null) {\n            this.tree.free();\n            this.tree = null;\n        }\n    }\n\n    /**\n     * Synchronously add the given quad to the store\n     * @param {*} quad The RDF.JS quad to add\n     */\n    addQuad(quad) {\n        let quadIndexes = this.indexer.findOrAddIndexes(quad);\n        this.tree.add(quadIndexes[0], quadIndexes[1], quadIndexes[2], quadIndexes[3]);\n        return this;\n    }\n\n    /**\n     * Synchronously add the given quad to the store\n     * @param {*} quad The RDF.JS quad to add\n     */\n    add(quad) {\n        return this.addQuad(quad);\n    }\n}\n\n/**\n * Builds a new wasm tree store containing every quad from the stream\n * @param {RDF.Stream} stream The stream containing the quads.\n */\nfunction storeStream(stream) {\n    const store = new TreeStore();\n    return new Promise(resolve => store.import(stream).on(\"end\", () => resolve(store)));\n}\n\n// Exports\n\nmodule.exports = {};\n\nmodule.exports.TreeDataset = TreeDataset;\nmodule.exports.TreeStore = TreeStore;\n\nmodule.exports.Dataset = TreeDataset;\nmodule.exports.Store = TreeStore;\n\nmodule.exports.storeStream = storeStream;\n\n\n//# sourceURL=webpack:///../WasmTreeDataset/wasm-tree-frontend/index.js?");

/***/ }),

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* == BENCHMARKED LIBRARIES == */\n// https://github.com/BruJu/WasmTreeDataset\nconst wasmtree = __webpack_require__(/*! ../WasmTreeDataset/wasm-tree-frontend */ \"../WasmTreeDataset/wasm-tree-frontend/index.js\");\n// https://github.com/BruJu/Portable-Reasoning-in-Web-Assembly\nconst sophia_wasm = __webpack_require__(/*! ../Portable-Reasoning-in-Web-Assembly/sophia-wasm/pkg */ \"../Portable-Reasoning-in-Web-Assembly/sophia-wasm/pkg/sophia_wasm.js\")\n\n/* == OTHER LIBRARIES (can be used both as a baseline and to steal their functions) == */\nconst factory = __webpack_require__(/*! @graphy/core.data.factory */ \"./node_modules/@graphy/core.data.factory/main.js\");\nconst n3 = __webpack_require__(/*! n3 */ \"./node_modules/n3/src/index.js\");\n//const graphy = require(\"graphy\");\n\n/* == ACTUAL CODE == */\n\nfunction populateSourceFiles() {\n    let select = $(\"#sourcefile\");\n    select.empty();\n\n    const availableFiles = [\n        { \"triples\":    10000, \"filename\": \"persondata_en_10k.ttl\"},\n        { \"triples\":    20000, \"filename\": \"persondata_en_20k.ttl\"},\n//        { \"triples\":    40000, \"filename\": \"persondata_en_40k.ttl\"},\n//        { \"triples\":    80000, \"filename\": \"persondata_en_80k.ttl\"},\n//        { \"triples\":   100000, \"filename\": \"persondata_en_100k.ttl\"},\n//        { \"triples\":  1000000, \"filename\": \"persondata_en_1M.ttl\"},\n//        { \"triples\": 10310106, \"filename\": \"persondata_en.ttl\"}\n    ];\n\n    $.each(availableFiles, function() {\n        select.append(\n            $('<option />')\n                .val(this.filename)\n                .text(this.filename + \" (\" + this.triples + \" triples)\")\n        );\n    });\n}\n\npopulateSourceFiles();\n\ndatasetKinds = {};\nfunction addDatasetKind(initializer, name) {\n    let select = $(\"#datasetkind\");\n\n    datasetKinds[name] = initializer;\n\n    select.append($('<option></option>')\n        .attr('value', name)\n        .text(name));\n}\n\naddDatasetKind(() => new wasmtree.Dataset(), \"Wasm Tree\");\naddDatasetKind(() => new sophia_wasm.ArrayDataset(), \"Array Dataset\");\n\n// Returns a pattern in the form of an array of 4 terms\n// Aligned with sophia_rdf_wasm_benchmark (or whatever name I gave to my sophia_benchmark fork)\nfunction getPatternForRequest(requestNumber) {\n    let pattern = [undefined, undefined, undefined, undefined];\n    if (requestNumber == 1 || requestNumber == 3) {\n        pattern[1] = n3.DataFactory.namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type');\n        pattern[2] = n3.DataFactory.namedNode('http://dbpedia.org/ontology/Person');\n    }\n    \n    if (requestNumber == 2 || requestNumber == 4) {\n        pattern[0] = n3.DataFactory.namedNode('http://dbpedia.org/resource/Vincent_Descombes_Sevoie');\n    }\n\n    if (requestNumber <= 2) {\n        pattern[3] = n3.DataFactory.defaultGraph();\n    }\n\n    return pattern;\n}\n\n// Returns dataset.match(matchPattern)\nfunction applyMatch(dataset, matchPattern) {\n    return dataset.match(matchPattern[0], matchPattern[1], matchPattern[2], matchPattern[3]);\n}\n\nfunction benchmark(datasetInstancier, datasetFilename, requestNumber, callback) {\n    $.get(datasetFilename, function (content) {\n        function freeDataset(ds) {\n            if (ds.free !== undefined) {\n                ds.free();\n            }\n        }\n\n        const parser = new n3.Parser();\n        let result = parser.parse(content);\n        // Fill the dataset\n        const dataset = datasetInstancier();\n\n        const beginFillTime = performance.now();\n        dataset.addAll(result);\n        const endFillTime = performance.now();\n\n        // Prepare match\n        const matchPattern = getPatternForRequest(requestNumber);\n\n        // First match (used to trigger any caching system)\n        freeDataset(applyMatch(dataset, matchPattern));\n\n        // Second match (measured)\n        const beginSecondMatchTime = performance.now();\n        const matchResult = applyMatch(dataset, matchPattern);\n        const endSecondMatchTime = performance.now();\n\n        const beginForEachMeasure = performance.now();\n        let n = 0;\n        matchResult.forEach(_ => { ++n; });\n        const endForEachMeasure = performance.now();\n\n        freeDataset(matchResult);\n\n        freeDataset(dataset);\n\n        if (callback !== undefined) {\n            callback({\n                fill: endFillTime - beginFillTime,\n                cachedMatch: endSecondMatchTime - beginSecondMatchTime,\n                forEachTime: endForEachMeasure - beginForEachMeasure,\n                forEachCount: n\n            });\n        }\n    },'text');\n}\n\n//benchmark(() => new wasmtree.Dataset(), \"persondata_en_1M.ttl\", 1, \n//    console.log\n//);\n\nfunction startbenchmark() {\n    let file = $(\"#sourcefile option:selected\").val();\n    let dataset = $(\"#datasetkind option:selected\").val();\n    let queryNumber = $(\"input[name='query']:checked\").val();\n\n    if (file == null || dataset == null || queryNumber == null) {\n        // TODO : error message\n        return;\n    }\n\n    let instancier = datasetKinds[dataset];\n    if (instancier == null) {\n        // TODO : error message\n        return;\n    }\n\n    $(\"#startbenchmark\").attr(\"disabled\", \"true\");\n\n    benchmark(instancier, file, parseInt(queryNumber),\n        results => {\n            function f(num) {\n                return num.toLocaleString(undefined, { maximumFractionDigits: 3, minimumFractionDigits: 0 });\n            }\n\n            let parsedResults = [];\n            parsedResults.push({ label: \"Fill (ms)\", value: f(results.fill) });\n            parsedResults.push({ label: \"Match (ms)\", value: f(results.cachedMatch) });\n            parsedResults.push({ label: \"Count (ms)\", value: f(results.forEachTime) });\n            parsedResults.push({ label: \"Match + Count (ms)\", value: f(results.cachedMatch + results.forEachTime) });\n            parsedResults.push({ label: \"# Quads\", value: results.forEachCount });\n\n            let template = $(\"#resulttable_template\").text();\n            let content = Mustache.render(template, parsedResults);\n            $(\"#resulttable\").html(content);\n\n            $(\"#startbenchmark\").attr(\"disabled\", false);\n        }\n    );\n}\n\n$(\"#startbenchmark\").click(startbenchmark);\n\n\n//# sourceURL=webpack:///./index.js?");

/***/ }),

/***/ 0:
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* (ignored) */\n\n//# sourceURL=webpack:///util_(ignored)?");

/***/ }),

/***/ 1:
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* (ignored) */\n\n//# sourceURL=webpack:///util_(ignored)?");

/***/ }),

/***/ 2:
/*!************************!*\
  !*** buffer (ignored) ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* (ignored) */\n\n//# sourceURL=webpack:///buffer_(ignored)?");

/***/ }),

/***/ 3:
/*!************************!*\
  !*** crypto (ignored) ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* (ignored) */\n\n//# sourceURL=webpack:///crypto_(ignored)?");

/***/ })

}]);